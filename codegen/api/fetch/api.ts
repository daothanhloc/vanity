/**
 * vanity
 * Vanity
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://localhost/api".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
};

export interface AccessToken {
    "id": string;
    /**
     * time to live in seconds (2 weeks by default)
     */
    "ttl"?: number;
    /**
     * Array of scopes granted to this access token.
     */
    "scopes"?: Array<string>;
    "created"?: Date;
    "userId"?: number;
}

export interface Account {
    "accountName"?: string;
    "realm"?: string;
    "username"?: string;
    "email": string;
    "emailVerified"?: boolean;
    "id"?: number;
}

export interface EffectScript {
    "type"?: string;
    "name": string;
    "color": string;
    "icon": string;
    "price": number;
    "description": string;
    "audio": string;
    "effectUrl": string;
    "id"?: number;
}

export interface History {
    "toPhoneNumber": number;
    "id"?: number;
    "accountId"?: number;
    "effectScriptId"?: number;
    "scriptId"?: number;
}

export interface InlineResponse200 {
    "count"?: number;
}

export interface InlineResponse2001 {
    "exists"?: boolean;
}

/**
 * Information related to the outcome of the operation
 */
export interface InlineResponse2002 {
    /**
     * The number of instances updated
     */
    "count"?: number;
}

export interface InlineResponse2003 {
    "undefined"?: any;
}

export interface InlineResponse2004 {
    "result"?: any;
}

export interface Message {
    "title": string;
    "content": string;
    "id"?: number;
    "fromUserId"?: number;
}

export interface PayEffectScript {
    "id"?: number;
    "accountId"?: number;
    "effectScriptId"?: number;
}

export interface User {
    "realm"?: string;
    "username"?: string;
    "email": string;
    "emailVerified"?: boolean;
    "id"?: number;
}



/**
 * AccountApi - fetch parameter creator
 */
export const AccountApiFetchParamCreator = {
    /**
     * 
     * @summary Change a user's password.
     * @param oldPassword 
     * @param newPassword 
     */
    accountChangePassword(params: {  "oldPassword": string; "newPassword": string; }, options?: any): FetchArgs {
        // verify required parameter "oldPassword" is set
        if (params["oldPassword"] == null) {
            throw new Error("Missing required parameter oldPassword when calling accountChangePassword");
        }
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling accountChangePassword");
        }
        const baseUrl = `/Accounts/change-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "oldPassword": params["oldPassword"],
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param uid 
     * @param token 
     * @param redirect 
     */
    accountConfirm(params: {  "uid": string; "token": string; "redirect"?: string; }, options?: any): FetchArgs {
        // verify required parameter "uid" is set
        if (params["uid"] == null) {
            throw new Error("Missing required parameter uid when calling accountConfirm");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            throw new Error("Missing required parameter token when calling accountConfirm");
        }
        const baseUrl = `/Accounts/confirm`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "uid": params["uid"],
            "token": params["token"],
            "redirect": params["redirect"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params: {  "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamGetAccountsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamPostAccountsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountDeleteById");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountExistsGetAccountsidExists");
        }
        const baseUrl = `/Accounts/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountExistsHeadAccountsid");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountFindById");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Login a user with username/email and password.
     * @param credentials 
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params: {  "credentials": any; "include"?: string; }, options?: any): FetchArgs {
        // verify required parameter "credentials" is set
        if (params["credentials"] == null) {
            throw new Error("Missing required parameter credentials when calling accountLogin");
        }
        const baseUrl = `/Accounts/login`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "include": params["include"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["credentials"]) {
            fetchOptions.body = JSON.stringify(params["credentials"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Logout a user with access token.
     */
    accountLogout(options?: any): FetchArgs {
        const baseUrl = `/Accounts/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params: {  "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCountAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts effectScripts of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountEffectScripts(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCountEffectScripts");
        }
        const baseUrl = `/Accounts/{id}/effectScripts/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts histories of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountHistories(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCountHistories");
        }
        const baseUrl = `/Accounts/{id}/histories/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts messages of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountMessages(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCountMessages");
        }
        const baseUrl = `/Accounts/{id}/messages/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateAccessTokens(params: {  "id": string; "data"?: AccessToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCreateAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in effectScripts of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateEffectScripts(params: {  "id": string; "data"?: EffectScript; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCreateEffectScripts");
        }
        const baseUrl = `/Accounts/{id}/effectScripts`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in histories of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateHistories(params: {  "id": string; "data"?: History; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCreateHistories");
        }
        const baseUrl = `/Accounts/{id}/histories`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in messages of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateMessages(params: {  "id": string; "data"?: Message; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCreateMessages");
        }
        const baseUrl = `/Accounts/{id}/messages`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDeleteAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all effectScripts of this model.
     * @param id Account id
     */
    accountPrototypeDeleteEffectScripts(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDeleteEffectScripts");
        }
        const baseUrl = `/Accounts/{id}/effectScripts`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all histories of this model.
     * @param id Account id
     */
    accountPrototypeDeleteHistories(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDeleteHistories");
        }
        const baseUrl = `/Accounts/{id}/histories`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all messages of this model.
     * @param id Account id
     */
    accountPrototypeDeleteMessages(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDeleteMessages");
        }
        const baseUrl = `/Accounts/{id}/messages`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDestroyByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeDestroyByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for effectScripts.
     * @param id Account id
     * @param fk Foreign key for effectScripts
     */
    accountPrototypeDestroyByIdEffectScripts(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDestroyByIdEffectScripts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeDestroyByIdEffectScripts");
        }
        const baseUrl = `/Accounts/{id}/effectScripts/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for histories.
     * @param id Account id
     * @param fk Foreign key for histories
     */
    accountPrototypeDestroyByIdHistories(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDestroyByIdHistories");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeDestroyByIdHistories");
        }
        const baseUrl = `/Accounts/{id}/histories/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for messages.
     * @param id Account id
     * @param fk Foreign key for messages
     */
    accountPrototypeDestroyByIdMessages(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDestroyByIdMessages");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeDestroyByIdMessages");
        }
        const baseUrl = `/Accounts/{id}/messages/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check the existence of effectScripts relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for effectScripts
     */
    accountPrototypeExistsEffectScripts(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeExistsEffectScripts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeExistsEffectScripts");
        }
        const baseUrl = `/Accounts/{id}/effectScripts/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeFindByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeFindByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for effectScripts.
     * @param id Account id
     * @param fk Foreign key for effectScripts
     */
    accountPrototypeFindByIdEffectScripts(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeFindByIdEffectScripts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeFindByIdEffectScripts");
        }
        const baseUrl = `/Accounts/{id}/effectScripts/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for histories.
     * @param id Account id
     * @param fk Foreign key for histories
     */
    accountPrototypeFindByIdHistories(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeFindByIdHistories");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeFindByIdHistories");
        }
        const baseUrl = `/Accounts/{id}/histories/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for messages.
     * @param id Account id
     * @param fk Foreign key for messages
     */
    accountPrototypeFindByIdMessages(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeFindByIdMessages");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeFindByIdMessages");
        }
        const baseUrl = `/Accounts/{id}/messages/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries effectScripts of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetEffectScripts(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetEffectScripts");
        }
        const baseUrl = `/Accounts/{id}/effectScripts`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries histories of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetHistories(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetHistories");
        }
        const baseUrl = `/Accounts/{id}/histories`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Account id
     * @param nk Foreign key for histories.
     * @param refresh 
     */
    accountPrototypeGetHistoriesAccount(params: {  "id": string; "nk": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetHistoriesAccount");
        }
        // verify required parameter "nk" is set
        if (params["nk"] == null) {
            throw new Error("Missing required parameter nk when calling accountPrototypeGetHistoriesAccount");
        }
        const baseUrl = `/Accounts/{id}/histories/{nk}/account`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"nk"}}`, `${ params["nk"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation effectScript.
     * @param id Account id
     * @param nk Foreign key for histories.
     * @param refresh 
     */
    accountPrototypeGetHistoriesEffectScript(params: {  "id": string; "nk": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetHistoriesEffectScript");
        }
        // verify required parameter "nk" is set
        if (params["nk"] == null) {
            throw new Error("Missing required parameter nk when calling accountPrototypeGetHistoriesEffectScript");
        }
        const baseUrl = `/Accounts/{id}/histories/{nk}/effectScript`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"nk"}}`, `${ params["nk"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries messages of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetMessages(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetMessages");
        }
        const baseUrl = `/Accounts/{id}/messages`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Account id
     * @param nk Foreign key for messages.
     * @param refresh 
     */
    accountPrototypeGetMessagesAccount(params: {  "id": string; "nk": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetMessagesAccount");
        }
        // verify required parameter "nk" is set
        if (params["nk"] == null) {
            throw new Error("Missing required parameter nk when calling accountPrototypeGetMessagesAccount");
        }
        const baseUrl = `/Accounts/{id}/messages/{nk}/account`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"nk"}}`, `${ params["nk"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Add a related item by id for effectScripts.
     * @param id Account id
     * @param fk Foreign key for effectScripts
     * @param data 
     */
    accountPrototypeLinkEffectScripts(params: {  "id": string; "fk": string; "data"?: PayEffectScript; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeLinkEffectScripts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeLinkEffectScripts");
        }
        const baseUrl = `/Accounts/{id}/effectScripts/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params: {  "id": string; "data"?: Account; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypePatchAttributes");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Remove the effectScripts relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for effectScripts
     */
    accountPrototypeUnlinkEffectScripts(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUnlinkEffectScripts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUnlinkEffectScripts");
        }
        const baseUrl = `/Accounts/{id}/effectScripts/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    accountPrototypeUpdateByIdAccessTokens(params: {  "id": string; "fk": string; "data"?: AccessToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUpdateByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUpdateByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for effectScripts.
     * @param id Account id
     * @param fk Foreign key for effectScripts
     * @param data 
     */
    accountPrototypeUpdateByIdEffectScripts(params: {  "id": string; "fk": string; "data"?: EffectScript; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUpdateByIdEffectScripts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUpdateByIdEffectScripts");
        }
        const baseUrl = `/Accounts/{id}/effectScripts/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for histories.
     * @param id Account id
     * @param fk Foreign key for histories
     * @param data 
     */
    accountPrototypeUpdateByIdHistories(params: {  "id": string; "fk": string; "data"?: History; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUpdateByIdHistories");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUpdateByIdHistories");
        }
        const baseUrl = `/Accounts/{id}/histories/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for messages.
     * @param id Account id
     * @param fk Foreign key for messages
     * @param data 
     */
    accountPrototypeUpdateByIdMessages(params: {  "id": string; "fk": string; "data"?: Message; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUpdateByIdMessages");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUpdateByIdMessages");
        }
        const baseUrl = `/Accounts/{id}/messages/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeVerify");
        }
        const baseUrl = `/Accounts/{id}/verify`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params: {  "id": string; "data"?: Account; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountReplaceByIdPostAccountsidReplace");
        }
        const baseUrl = `/Accounts/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params: {  "id": string; "data"?: Account; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountReplaceByIdPutAccountsid");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params: {  "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params: {  "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Reset password for a user with email.
     * @param options 
     */
    accountResetPassword(params: {  "options": any; }, options?: any): FetchArgs {
        // verify required parameter "options" is set
        if (params["options"] == null) {
            throw new Error("Missing required parameter options when calling accountResetPassword");
        }
        const baseUrl = `/Accounts/reset`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["options"]) {
            fetchOptions.body = JSON.stringify(params["options"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary send mail to user
     * @param userEmail email of user to send
     * @param content email content
     */
    accountSendMailToUser(params: {  "userEmail": string; "content": string; }, options?: any): FetchArgs {
        // verify required parameter "userEmail" is set
        if (params["userEmail"] == null) {
            throw new Error("Missing required parameter userEmail when calling accountSendMailToUser");
        }
        // verify required parameter "content" is set
        if (params["content"] == null) {
            throw new Error("Missing required parameter content when calling accountSendMailToUser");
        }
        const baseUrl = `/Accounts/sendMailToUser`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "userEmail": params["userEmail"],
            "content": params["content"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param newPassword 
     */
    accountSetPassword(params: {  "newPassword": string; }, options?: any): FetchArgs {
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling accountSetPassword");
        }
        const baseUrl = `/Accounts/reset-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params: {  "where"?: string; "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params: {  "where"?: string; "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AccountApi - functional programming interface
 */
export const AccountApiFp = {
    /**
     * 
     * @summary Change a user's password.
     * @param oldPassword 
     * @param newPassword 
     */
    accountChangePassword(params: { "oldPassword": string; "newPassword": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountChangePassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param uid 
     * @param token 
     * @param redirect 
     */
    accountConfirm(params: { "uid": string; "token": string; "redirect"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountConfirm(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = AccountApiFetchParamCreator.accountCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params: { "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamGetAccountsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountCreateChangeStreamGetAccountsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamPostAccountsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountCreateChangeStreamPostAccountsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = AccountApiFetchParamCreator.accountExistsGetAccountsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = AccountApiFetchParamCreator.accountExistsHeadAccountsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Account>> {
        const fetchArgs = AccountApiFetchParamCreator.accountFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Login a user with username/email and password.
     * @param credentials 
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params: { "credentials": any; "include"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountLogin(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Logout a user with access token.
     */
    accountLogout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountLogout(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params: { "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts effectScripts of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountEffectScripts(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts histories of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountHistories(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts messages of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountMessages(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountMessages(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateAccessTokens(params: { "id": string; "data"?: AccessToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in effectScripts of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateEffectScripts(params: { "id": string; "data"?: EffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in histories of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateHistories(params: { "id": string; "data"?: History;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in messages of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateMessages(params: { "id": string; "data"?: Message;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Message> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateMessages(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all effectScripts of this model.
     * @param id Account id
     */
    accountPrototypeDeleteEffectScripts(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all histories of this model.
     * @param id Account id
     */
    accountPrototypeDeleteHistories(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all messages of this model.
     * @param id Account id
     */
    accountPrototypeDeleteMessages(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteMessages(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for effectScripts.
     * @param id Account id
     * @param fk Foreign key for effectScripts
     */
    accountPrototypeDestroyByIdEffectScripts(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for histories.
     * @param id Account id
     * @param fk Foreign key for histories
     */
    accountPrototypeDestroyByIdHistories(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for messages.
     * @param id Account id
     * @param fk Foreign key for messages
     */
    accountPrototypeDestroyByIdMessages(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdMessages(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check the existence of effectScripts relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for effectScripts
     */
    accountPrototypeExistsEffectScripts(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeExistsEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for effectScripts.
     * @param id Account id
     * @param fk Foreign key for effectScripts
     */
    accountPrototypeFindByIdEffectScripts(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for histories.
     * @param id Account id
     * @param fk Foreign key for histories
     */
    accountPrototypeFindByIdHistories(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for messages.
     * @param id Account id
     * @param fk Foreign key for messages
     */
    accountPrototypeFindByIdMessages(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Message> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdMessages(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetAccessTokens(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccessToken>> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries effectScripts of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetEffectScripts(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EffectScript>> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries histories of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetHistories(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<History>> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Account id
     * @param nk Foreign key for histories.
     * @param refresh 
     */
    accountPrototypeGetHistoriesAccount(params: { "id": string; "nk": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetHistoriesAccount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation effectScript.
     * @param id Account id
     * @param nk Foreign key for histories.
     * @param refresh 
     */
    accountPrototypeGetHistoriesEffectScript(params: { "id": string; "nk": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetHistoriesEffectScript(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries messages of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetMessages(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Message>> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetMessages(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Account id
     * @param nk Foreign key for messages.
     * @param refresh 
     */
    accountPrototypeGetMessagesAccount(params: { "id": string; "nk": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetMessagesAccount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Add a related item by id for effectScripts.
     * @param id Account id
     * @param fk Foreign key for effectScripts
     * @param data 
     */
    accountPrototypeLinkEffectScripts(params: { "id": string; "fk": string; "data"?: PayEffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayEffectScript> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeLinkEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params: { "id": string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Remove the effectScripts relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for effectScripts
     */
    accountPrototypeUnlinkEffectScripts(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUnlinkEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    accountPrototypeUpdateByIdAccessTokens(params: { "id": string; "fk": string; "data"?: AccessToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for effectScripts.
     * @param id Account id
     * @param fk Foreign key for effectScripts
     * @param data 
     */
    accountPrototypeUpdateByIdEffectScripts(params: { "id": string; "fk": string; "data"?: EffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for histories.
     * @param id Account id
     * @param fk Foreign key for histories
     * @param data 
     */
    accountPrototypeUpdateByIdHistories(params: { "id": string; "fk": string; "data"?: History;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for messages.
     * @param id Account id
     * @param fk Foreign key for messages
     * @param data 
     */
    accountPrototypeUpdateByIdMessages(params: { "id": string; "fk": string; "data"?: Message;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Message> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdMessages(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeVerify(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params: { "id": string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountReplaceByIdPostAccountsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params: { "id": string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountReplaceByIdPutAccountsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params: { "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params: { "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountReplaceOrCreatePutAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Reset password for a user with email.
     * @param options 
     */
    accountResetPassword(params: { "options": any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountResetPassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary send mail to user
     * @param userEmail email of user to send
     * @param content email content
     */
    accountSendMailToUser(params: { "userEmail": string; "content": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountSendMailToUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param newPassword 
     */
    accountSetPassword(params: { "newPassword": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountSetPassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params: { "where"?: string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = AccountApiFetchParamCreator.accountUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params: { "where"?: string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AccountApi - object-oriented interface
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @summary Change a user's password.
     * @param oldPassword 
     * @param newPassword 
     */
    accountChangePassword(params: {  "oldPassword": string; "newPassword": string; }, options?: any) {
        return AccountApiFp.accountChangePassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param uid 
     * @param token 
     * @param redirect 
     */
    accountConfirm(params: {  "uid": string; "token": string; "redirect"?: string; }, options?: any) {
        return AccountApiFp.accountConfirm(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params: {  "where"?: string; }, options?: any) {
        return AccountApiFp.accountCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params: {  "data"?: Account; }, options?: any) {
        return AccountApiFp.accountCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamGetAccountsChangeStream(params: {  "options"?: string; }, options?: any) {
        return AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamPostAccountsChangeStream(params: {  "options"?: string; }, options?: any) {
        return AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountExistsGetAccountsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountExistsHeadAccountsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params: {  "filter"?: string; }, options?: any) {
        return AccountApiFp.accountFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountApiFp.accountFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params: {  "filter"?: string; }, options?: any) {
        return AccountApiFp.accountFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Login a user with username/email and password.
     * @param credentials 
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params: {  "credentials": any; "include"?: string; }, options?: any) {
        return AccountApiFp.accountLogin(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Logout a user with access token.
     */
    accountLogout(options?: any) {
        return AccountApiFp.accountLogout(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params: {  "data"?: Account; }, options?: any) {
        return AccountApiFp.accountPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeCountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts effectScripts of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountEffectScripts(params: {  "id": string; "where"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeCountEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts histories of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountHistories(params: {  "id": string; "where"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeCountHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts messages of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountMessages(params: {  "id": string; "where"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeCountMessages(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateAccessTokens(params: {  "id": string; "data"?: AccessToken; }, options?: any) {
        return AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in effectScripts of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateEffectScripts(params: {  "id": string; "data"?: EffectScript; }, options?: any) {
        return AccountApiFp.accountPrototypeCreateEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in histories of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateHistories(params: {  "id": string; "data"?: History; }, options?: any) {
        return AccountApiFp.accountPrototypeCreateHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in messages of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateMessages(params: {  "id": string; "data"?: Message; }, options?: any) {
        return AccountApiFp.accountPrototypeCreateMessages(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all effectScripts of this model.
     * @param id Account id
     */
    accountPrototypeDeleteEffectScripts(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDeleteEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all histories of this model.
     * @param id Account id
     */
    accountPrototypeDeleteHistories(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDeleteHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all messages of this model.
     * @param id Account id
     */
    accountPrototypeDeleteMessages(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDeleteMessages(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for effectScripts.
     * @param id Account id
     * @param fk Foreign key for effectScripts
     */
    accountPrototypeDestroyByIdEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDestroyByIdEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for histories.
     * @param id Account id
     * @param fk Foreign key for histories
     */
    accountPrototypeDestroyByIdHistories(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDestroyByIdHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for messages.
     * @param id Account id
     * @param fk Foreign key for messages
     */
    accountPrototypeDestroyByIdMessages(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDestroyByIdMessages(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check the existence of effectScripts relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for effectScripts
     */
    accountPrototypeExistsEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeExistsEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for effectScripts.
     * @param id Account id
     * @param fk Foreign key for effectScripts
     */
    accountPrototypeFindByIdEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeFindByIdEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for histories.
     * @param id Account id
     * @param fk Foreign key for histories
     */
    accountPrototypeFindByIdHistories(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeFindByIdHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for messages.
     * @param id Account id
     * @param fk Foreign key for messages
     */
    accountPrototypeFindByIdMessages(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeFindByIdMessages(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeGetAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries effectScripts of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetEffectScripts(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeGetEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries histories of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetHistories(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeGetHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Account id
     * @param nk Foreign key for histories.
     * @param refresh 
     */
    accountPrototypeGetHistoriesAccount(params: {  "id": string; "nk": string; "refresh"?: boolean; }, options?: any) {
        return AccountApiFp.accountPrototypeGetHistoriesAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation effectScript.
     * @param id Account id
     * @param nk Foreign key for histories.
     * @param refresh 
     */
    accountPrototypeGetHistoriesEffectScript(params: {  "id": string; "nk": string; "refresh"?: boolean; }, options?: any) {
        return AccountApiFp.accountPrototypeGetHistoriesEffectScript(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries messages of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetMessages(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeGetMessages(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Account id
     * @param nk Foreign key for messages.
     * @param refresh 
     */
    accountPrototypeGetMessagesAccount(params: {  "id": string; "nk": string; "refresh"?: boolean; }, options?: any) {
        return AccountApiFp.accountPrototypeGetMessagesAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Add a related item by id for effectScripts.
     * @param id Account id
     * @param fk Foreign key for effectScripts
     * @param data 
     */
    accountPrototypeLinkEffectScripts(params: {  "id": string; "fk": string; "data"?: PayEffectScript; }, options?: any) {
        return AccountApiFp.accountPrototypeLinkEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params: {  "id": string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Remove the effectScripts relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for effectScripts
     */
    accountPrototypeUnlinkEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeUnlinkEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    accountPrototypeUpdateByIdAccessTokens(params: {  "id": string; "fk": string; "data"?: AccessToken; }, options?: any) {
        return AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for effectScripts.
     * @param id Account id
     * @param fk Foreign key for effectScripts
     * @param data 
     */
    accountPrototypeUpdateByIdEffectScripts(params: {  "id": string; "fk": string; "data"?: EffectScript; }, options?: any) {
        return AccountApiFp.accountPrototypeUpdateByIdEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for histories.
     * @param id Account id
     * @param fk Foreign key for histories
     * @param data 
     */
    accountPrototypeUpdateByIdHistories(params: {  "id": string; "fk": string; "data"?: History; }, options?: any) {
        return AccountApiFp.accountPrototypeUpdateByIdHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for messages.
     * @param id Account id
     * @param fk Foreign key for messages
     * @param data 
     */
    accountPrototypeUpdateByIdMessages(params: {  "id": string; "fk": string; "data"?: Message; }, options?: any) {
        return AccountApiFp.accountPrototypeUpdateByIdMessages(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountPrototypeVerify(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params: {  "id": string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params: {  "id": string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params: {  "data"?: Account; }, options?: any) {
        return AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params: {  "data"?: Account; }, options?: any) {
        return AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Reset password for a user with email.
     * @param options 
     */
    accountResetPassword(params: {  "options": any; }, options?: any) {
        return AccountApiFp.accountResetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary send mail to user
     * @param userEmail email of user to send
     * @param content email content
     */
    accountSendMailToUser(params: {  "userEmail": string; "content": string; }, options?: any) {
        return AccountApiFp.accountSendMailToUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param newPassword 
     */
    accountSetPassword(params: {  "newPassword": string; }, options?: any) {
        return AccountApiFp.accountSetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params: {  "where"?: string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params: {  "where"?: string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AccountApi - factory interface
 */
export const AccountApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Change a user's password.
         * @param oldPassword 
         * @param newPassword 
         */
        accountChangePassword(params: {  "oldPassword": string; "newPassword": string; }, options?: any) {
            return AccountApiFp.accountChangePassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Confirm a user registration with identity verification token.
         * @param uid 
         * @param token 
         * @param redirect 
         */
        accountConfirm(params: {  "uid": string; "token": string; "redirect"?: string; }, options?: any) {
            return AccountApiFp.accountConfirm(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        accountCount(params: {  "where"?: string; }, options?: any) {
            return AccountApiFp.accountCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        accountCreate(params: {  "data"?: Account; }, options?: any) {
            return AccountApiFp.accountCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        accountCreateChangeStreamGetAccountsChangeStream(params: {  "options"?: string; }, options?: any) {
            return AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        accountCreateChangeStreamPostAccountsChangeStream(params: {  "options"?: string; }, options?: any) {
            return AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        accountDeleteById(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountExistsGetAccountsidExists(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountExistsGetAccountsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountExistsHeadAccountsid(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountExistsHeadAccountsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountFind(params: {  "filter"?: string; }, options?: any) {
            return AccountApiFp.accountFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountApiFp.accountFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountFindOne(params: {  "filter"?: string; }, options?: any) {
            return AccountApiFp.accountFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Login a user with username/email and password.
         * @param credentials 
         * @param include Related objects to include in the response. See the description of return value for more details.
         */
        accountLogin(params: {  "credentials": any; "include"?: string; }, options?: any) {
            return AccountApiFp.accountLogin(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Logout a user with access token.
         */
        accountLogout(options?: any) {
            return AccountApiFp.accountLogout(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountPatchOrCreate(params: {  "data"?: Account; }, options?: any) {
            return AccountApiFp.accountPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts accessTokens of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeCountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts effectScripts of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountEffectScripts(params: {  "id": string; "where"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeCountEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts histories of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountHistories(params: {  "id": string; "where"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeCountHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts messages of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountMessages(params: {  "id": string; "where"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeCountMessages(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in accessTokens of this model.
         * @param id Account id
         * @param data 
         */
        accountPrototypeCreateAccessTokens(params: {  "id": string; "data"?: AccessToken; }, options?: any) {
            return AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in effectScripts of this model.
         * @param id Account id
         * @param data 
         */
        accountPrototypeCreateEffectScripts(params: {  "id": string; "data"?: EffectScript; }, options?: any) {
            return AccountApiFp.accountPrototypeCreateEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in histories of this model.
         * @param id Account id
         * @param data 
         */
        accountPrototypeCreateHistories(params: {  "id": string; "data"?: History; }, options?: any) {
            return AccountApiFp.accountPrototypeCreateHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in messages of this model.
         * @param id Account id
         * @param data 
         */
        accountPrototypeCreateMessages(params: {  "id": string; "data"?: Message; }, options?: any) {
            return AccountApiFp.accountPrototypeCreateMessages(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all accessTokens of this model.
         * @param id Account id
         */
        accountPrototypeDeleteAccessTokens(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all effectScripts of this model.
         * @param id Account id
         */
        accountPrototypeDeleteEffectScripts(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDeleteEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all histories of this model.
         * @param id Account id
         */
        accountPrototypeDeleteHistories(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDeleteHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all messages of this model.
         * @param id Account id
         */
        accountPrototypeDeleteMessages(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDeleteMessages(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         */
        accountPrototypeDestroyByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for effectScripts.
         * @param id Account id
         * @param fk Foreign key for effectScripts
         */
        accountPrototypeDestroyByIdEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDestroyByIdEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for histories.
         * @param id Account id
         * @param fk Foreign key for histories
         */
        accountPrototypeDestroyByIdHistories(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDestroyByIdHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for messages.
         * @param id Account id
         * @param fk Foreign key for messages
         */
        accountPrototypeDestroyByIdMessages(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDestroyByIdMessages(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check the existence of effectScripts relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for effectScripts
         */
        accountPrototypeExistsEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeExistsEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         */
        accountPrototypeFindByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for effectScripts.
         * @param id Account id
         * @param fk Foreign key for effectScripts
         */
        accountPrototypeFindByIdEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeFindByIdEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for histories.
         * @param id Account id
         * @param fk Foreign key for histories
         */
        accountPrototypeFindByIdHistories(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeFindByIdHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for messages.
         * @param id Account id
         * @param fk Foreign key for messages
         */
        accountPrototypeFindByIdMessages(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeFindByIdMessages(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries accessTokens of Account.
         * @param id Account id
         * @param filter 
         */
        accountPrototypeGetAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeGetAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries effectScripts of Account.
         * @param id Account id
         * @param filter 
         */
        accountPrototypeGetEffectScripts(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeGetEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries histories of Account.
         * @param id Account id
         * @param filter 
         */
        accountPrototypeGetHistories(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeGetHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation account.
         * @param id Account id
         * @param nk Foreign key for histories.
         * @param refresh 
         */
        accountPrototypeGetHistoriesAccount(params: {  "id": string; "nk": string; "refresh"?: boolean; }, options?: any) {
            return AccountApiFp.accountPrototypeGetHistoriesAccount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation effectScript.
         * @param id Account id
         * @param nk Foreign key for histories.
         * @param refresh 
         */
        accountPrototypeGetHistoriesEffectScript(params: {  "id": string; "nk": string; "refresh"?: boolean; }, options?: any) {
            return AccountApiFp.accountPrototypeGetHistoriesEffectScript(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries messages of Account.
         * @param id Account id
         * @param filter 
         */
        accountPrototypeGetMessages(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeGetMessages(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation account.
         * @param id Account id
         * @param nk Foreign key for messages.
         * @param refresh 
         */
        accountPrototypeGetMessagesAccount(params: {  "id": string; "nk": string; "refresh"?: boolean; }, options?: any) {
            return AccountApiFp.accountPrototypeGetMessagesAccount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add a related item by id for effectScripts.
         * @param id Account id
         * @param fk Foreign key for effectScripts
         * @param data 
         */
        accountPrototypeLinkEffectScripts(params: {  "id": string; "fk": string; "data"?: PayEffectScript; }, options?: any) {
            return AccountApiFp.accountPrototypeLinkEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Account id
         * @param data An object of model property name/value pairs
         */
        accountPrototypePatchAttributes(params: {  "id": string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the effectScripts relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for effectScripts
         */
        accountPrototypeUnlinkEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeUnlinkEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         * @param data 
         */
        accountPrototypeUpdateByIdAccessTokens(params: {  "id": string; "fk": string; "data"?: AccessToken; }, options?: any) {
            return AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for effectScripts.
         * @param id Account id
         * @param fk Foreign key for effectScripts
         * @param data 
         */
        accountPrototypeUpdateByIdEffectScripts(params: {  "id": string; "fk": string; "data"?: EffectScript; }, options?: any) {
            return AccountApiFp.accountPrototypeUpdateByIdEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for histories.
         * @param id Account id
         * @param fk Foreign key for histories
         * @param data 
         */
        accountPrototypeUpdateByIdHistories(params: {  "id": string; "fk": string; "data"?: History; }, options?: any) {
            return AccountApiFp.accountPrototypeUpdateByIdHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for messages.
         * @param id Account id
         * @param fk Foreign key for messages
         * @param data 
         */
        accountPrototypeUpdateByIdMessages(params: {  "id": string; "fk": string; "data"?: Message; }, options?: any) {
            return AccountApiFp.accountPrototypeUpdateByIdMessages(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Trigger user's identity verification with configured verifyOptions
         * @param id Account id
         */
        accountPrototypeVerify(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountPrototypeVerify(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountReplaceByIdPostAccountsidReplace(params: {  "id": string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountReplaceByIdPutAccountsid(params: {  "id": string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountReplaceOrCreatePostAccountsReplaceOrCreate(params: {  "data"?: Account; }, options?: any) {
            return AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountReplaceOrCreatePutAccounts(params: {  "data"?: Account; }, options?: any) {
            return AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reset password for a user with email.
         * @param options 
         */
        accountResetPassword(params: {  "options": any; }, options?: any) {
            return AccountApiFp.accountResetPassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary send mail to user
         * @param userEmail email of user to send
         * @param content email content
         */
        accountSendMailToUser(params: {  "userEmail": string; "content": string; }, options?: any) {
            return AccountApiFp.accountSendMailToUser(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reset user's password via a password-reset token.
         * @param newPassword 
         */
        accountSetPassword(params: {  "newPassword": string; }, options?: any) {
            return AccountApiFp.accountSetPassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountUpdateAll(params: {  "where"?: string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountUpsertWithWhere(params: {  "where"?: string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * ContainerApi - fetch parameter creator
 */
export const ContainerApiFetchParamCreator = {
    /**
     * 
     * @param options 
     */
    containerCreateContainer(params: {  "options"?: any; }, options?: any): FetchArgs {
        const baseUrl = `/Containers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["options"]) {
            fetchOptions.body = JSON.stringify(params["options"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     */
    containerDestroyContainer(params: {  "container": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerDestroyContainer");
        }
        const baseUrl = `/Containers/{container}`
            .replace(`{${"container"}}`, `${ params["container"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerDownload(params: {  "container": string; "file": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerDownload");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerDownload");
        }
        const baseUrl = `/Containers/{container}/download/{file}`
            .replace(`{${"container"}}`, `${ params["container"] }`)
            .replace(`{${"file"}}`, `${ params["file"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     */
    containerGetContainer(params: {  "container": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetContainer");
        }
        const baseUrl = `/Containers/{container}`
            .replace(`{${"container"}}`, `${ params["container"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    containerGetContainers(options?: any): FetchArgs {
        const baseUrl = `/Containers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerGetFile(params: {  "container": string; "file": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetFile");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerGetFile");
        }
        const baseUrl = `/Containers/{container}/files/{file}`
            .replace(`{${"container"}}`, `${ params["container"] }`)
            .replace(`{${"file"}}`, `${ params["file"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     */
    containerGetFiles(params: {  "container": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetFiles");
        }
        const baseUrl = `/Containers/{container}/files`
            .replace(`{${"container"}}`, `${ params["container"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerRemoveFile(params: {  "container": string; "file": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerRemoveFile");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerRemoveFile");
        }
        const baseUrl = `/Containers/{container}/files/{file}`
            .replace(`{${"container"}}`, `${ params["container"] }`)
            .replace(`{${"file"}}`, `${ params["file"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     */
    containerUpload(params: {  "container": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerUpload");
        }
        const baseUrl = `/Containers/{container}/upload`
            .replace(`{${"container"}}`, `${ params["container"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ContainerApi - functional programming interface
 */
export const ContainerApiFp = {
    /**
     * 
     * @param options 
     */
    containerCreateContainer(params: { "options"?: any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContainerApiFetchParamCreator.containerCreateContainer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     */
    containerDestroyContainer(params: { "container": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = ContainerApiFetchParamCreator.containerDestroyContainer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerDownload(params: { "container": string; "file": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContainerApiFetchParamCreator.containerDownload(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     */
    containerGetContainer(params: { "container": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContainerApiFetchParamCreator.containerGetContainer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    containerGetContainers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
        const fetchArgs = ContainerApiFetchParamCreator.containerGetContainers(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerGetFile(params: { "container": string; "file": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContainerApiFetchParamCreator.containerGetFile(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     */
    containerGetFiles(params: { "container": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
        const fetchArgs = ContainerApiFetchParamCreator.containerGetFiles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerRemoveFile(params: { "container": string; "file": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = ContainerApiFetchParamCreator.containerRemoveFile(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     */
    containerUpload(params: { "container": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = ContainerApiFetchParamCreator.containerUpload(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ContainerApi - object-oriented interface
 */
export class ContainerApi extends BaseAPI {
    /**
     * 
     * @param options 
     */
    containerCreateContainer(params: {  "options"?: any; }, options?: any) {
        return ContainerApiFp.containerCreateContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     */
    containerDestroyContainer(params: {  "container": string; }, options?: any) {
        return ContainerApiFp.containerDestroyContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     * @param file 
     */
    containerDownload(params: {  "container": string; "file": string; }, options?: any) {
        return ContainerApiFp.containerDownload(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     */
    containerGetContainer(params: {  "container": string; }, options?: any) {
        return ContainerApiFp.containerGetContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    containerGetContainers(options?: any) {
        return ContainerApiFp.containerGetContainers(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     * @param file 
     */
    containerGetFile(params: {  "container": string; "file": string; }, options?: any) {
        return ContainerApiFp.containerGetFile(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     */
    containerGetFiles(params: {  "container": string; }, options?: any) {
        return ContainerApiFp.containerGetFiles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     * @param file 
     */
    containerRemoveFile(params: {  "container": string; "file": string; }, options?: any) {
        return ContainerApiFp.containerRemoveFile(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     */
    containerUpload(params: {  "container": string; }, options?: any) {
        return ContainerApiFp.containerUpload(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ContainerApi - factory interface
 */
export const ContainerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param options 
         */
        containerCreateContainer(params: {  "options"?: any; }, options?: any) {
            return ContainerApiFp.containerCreateContainer(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         */
        containerDestroyContainer(params: {  "container": string; }, options?: any) {
            return ContainerApiFp.containerDestroyContainer(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         * @param file 
         */
        containerDownload(params: {  "container": string; "file": string; }, options?: any) {
            return ContainerApiFp.containerDownload(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         */
        containerGetContainer(params: {  "container": string; }, options?: any) {
            return ContainerApiFp.containerGetContainer(params, options)(fetch, basePath);
        },
        /**
         * 
         */
        containerGetContainers(options?: any) {
            return ContainerApiFp.containerGetContainers(options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         * @param file 
         */
        containerGetFile(params: {  "container": string; "file": string; }, options?: any) {
            return ContainerApiFp.containerGetFile(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         */
        containerGetFiles(params: {  "container": string; }, options?: any) {
            return ContainerApiFp.containerGetFiles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         * @param file 
         */
        containerRemoveFile(params: {  "container": string; "file": string; }, options?: any) {
            return ContainerApiFp.containerRemoveFile(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         */
        containerUpload(params: {  "container": string; }, options?: any) {
            return ContainerApiFp.containerUpload(params, options)(fetch, basePath);
        },
    };
};


/**
 * EffectScriptApi - fetch parameter creator
 */
export const EffectScriptApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    effectScriptCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/EffectScripts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    effectScriptCreate(params: {  "data"?: EffectScript; }, options?: any): FetchArgs {
        const baseUrl = `/EffectScripts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    effectScriptCreateChangeStreamGetEffectScriptsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/EffectScripts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    effectScriptCreateChangeStreamPostEffectScriptsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/EffectScripts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    effectScriptDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptDeleteById");
        }
        const baseUrl = `/EffectScripts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    effectScriptExistsGetEffectScriptsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptExistsGetEffectScriptsidExists");
        }
        const baseUrl = `/EffectScripts/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    effectScriptExistsHeadEffectScriptsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptExistsHeadEffectScriptsid");
        }
        const baseUrl = `/EffectScripts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    effectScriptFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/EffectScripts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    effectScriptFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptFindById");
        }
        const baseUrl = `/EffectScripts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    effectScriptFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/EffectScripts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    effectScriptPatchOrCreate(params: {  "data"?: EffectScript; }, options?: any): FetchArgs {
        const baseUrl = `/EffectScripts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts accounts of EffectScript.
     * @param id EffectScript id
     * @param where Criteria to match model instances
     */
    effectScriptPrototypeCountAccounts(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptPrototypeCountAccounts");
        }
        const baseUrl = `/EffectScripts/{id}/accounts/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts histories of EffectScript.
     * @param id EffectScript id
     * @param where Criteria to match model instances
     */
    effectScriptPrototypeCountHistories(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptPrototypeCountHistories");
        }
        const baseUrl = `/EffectScripts/{id}/histories/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in accounts of this model.
     * @param id EffectScript id
     * @param data 
     */
    effectScriptPrototypeCreateAccounts(params: {  "id": string; "data"?: Account; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptPrototypeCreateAccounts");
        }
        const baseUrl = `/EffectScripts/{id}/accounts`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in histories of this model.
     * @param id EffectScript id
     * @param data 
     */
    effectScriptPrototypeCreateHistories(params: {  "id": string; "data"?: History; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptPrototypeCreateHistories");
        }
        const baseUrl = `/EffectScripts/{id}/histories`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all accounts of this model.
     * @param id EffectScript id
     */
    effectScriptPrototypeDeleteAccounts(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptPrototypeDeleteAccounts");
        }
        const baseUrl = `/EffectScripts/{id}/accounts`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all histories of this model.
     * @param id EffectScript id
     */
    effectScriptPrototypeDeleteHistories(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptPrototypeDeleteHistories");
        }
        const baseUrl = `/EffectScripts/{id}/histories`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accounts.
     * @param id EffectScript id
     * @param fk Foreign key for accounts
     */
    effectScriptPrototypeDestroyByIdAccounts(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptPrototypeDestroyByIdAccounts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling effectScriptPrototypeDestroyByIdAccounts");
        }
        const baseUrl = `/EffectScripts/{id}/accounts/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for histories.
     * @param id EffectScript id
     * @param fk Foreign key for histories
     */
    effectScriptPrototypeDestroyByIdHistories(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptPrototypeDestroyByIdHistories");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling effectScriptPrototypeDestroyByIdHistories");
        }
        const baseUrl = `/EffectScripts/{id}/histories/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check the existence of accounts relation to an item by id.
     * @param id EffectScript id
     * @param fk Foreign key for accounts
     */
    effectScriptPrototypeExistsAccounts(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptPrototypeExistsAccounts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling effectScriptPrototypeExistsAccounts");
        }
        const baseUrl = `/EffectScripts/{id}/accounts/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for accounts.
     * @param id EffectScript id
     * @param fk Foreign key for accounts
     */
    effectScriptPrototypeFindByIdAccounts(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptPrototypeFindByIdAccounts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling effectScriptPrototypeFindByIdAccounts");
        }
        const baseUrl = `/EffectScripts/{id}/accounts/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for histories.
     * @param id EffectScript id
     * @param fk Foreign key for histories
     */
    effectScriptPrototypeFindByIdHistories(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptPrototypeFindByIdHistories");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling effectScriptPrototypeFindByIdHistories");
        }
        const baseUrl = `/EffectScripts/{id}/histories/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries accounts of EffectScript.
     * @param id EffectScript id
     * @param filter 
     */
    effectScriptPrototypeGetAccounts(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptPrototypeGetAccounts");
        }
        const baseUrl = `/EffectScripts/{id}/accounts`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries histories of EffectScript.
     * @param id EffectScript id
     * @param filter 
     */
    effectScriptPrototypeGetHistories(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptPrototypeGetHistories");
        }
        const baseUrl = `/EffectScripts/{id}/histories`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id EffectScript id
     * @param nk Foreign key for histories.
     * @param refresh 
     */
    effectScriptPrototypeGetHistoriesAccount(params: {  "id": string; "nk": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptPrototypeGetHistoriesAccount");
        }
        // verify required parameter "nk" is set
        if (params["nk"] == null) {
            throw new Error("Missing required parameter nk when calling effectScriptPrototypeGetHistoriesAccount");
        }
        const baseUrl = `/EffectScripts/{id}/histories/{nk}/account`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"nk"}}`, `${ params["nk"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation effectScript.
     * @param id EffectScript id
     * @param nk Foreign key for histories.
     * @param refresh 
     */
    effectScriptPrototypeGetHistoriesEffectScript(params: {  "id": string; "nk": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptPrototypeGetHistoriesEffectScript");
        }
        // verify required parameter "nk" is set
        if (params["nk"] == null) {
            throw new Error("Missing required parameter nk when calling effectScriptPrototypeGetHistoriesEffectScript");
        }
        const baseUrl = `/EffectScripts/{id}/histories/{nk}/effectScript`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"nk"}}`, `${ params["nk"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Add a related item by id for accounts.
     * @param id EffectScript id
     * @param fk Foreign key for accounts
     * @param data 
     */
    effectScriptPrototypeLinkAccounts(params: {  "id": string; "fk": string; "data"?: PayEffectScript; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptPrototypeLinkAccounts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling effectScriptPrototypeLinkAccounts");
        }
        const baseUrl = `/EffectScripts/{id}/accounts/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id EffectScript id
     * @param data An object of model property name/value pairs
     */
    effectScriptPrototypePatchAttributes(params: {  "id": string; "data"?: EffectScript; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptPrototypePatchAttributes");
        }
        const baseUrl = `/EffectScripts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Remove the accounts relation to an item by id.
     * @param id EffectScript id
     * @param fk Foreign key for accounts
     */
    effectScriptPrototypeUnlinkAccounts(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptPrototypeUnlinkAccounts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling effectScriptPrototypeUnlinkAccounts");
        }
        const baseUrl = `/EffectScripts/{id}/accounts/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for accounts.
     * @param id EffectScript id
     * @param fk Foreign key for accounts
     * @param data 
     */
    effectScriptPrototypeUpdateByIdAccounts(params: {  "id": string; "fk": string; "data"?: Account; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptPrototypeUpdateByIdAccounts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling effectScriptPrototypeUpdateByIdAccounts");
        }
        const baseUrl = `/EffectScripts/{id}/accounts/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for histories.
     * @param id EffectScript id
     * @param fk Foreign key for histories
     * @param data 
     */
    effectScriptPrototypeUpdateByIdHistories(params: {  "id": string; "fk": string; "data"?: History; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptPrototypeUpdateByIdHistories");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling effectScriptPrototypeUpdateByIdHistories");
        }
        const baseUrl = `/EffectScripts/{id}/histories/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    effectScriptReplaceByIdPostEffectScriptsidReplace(params: {  "id": string; "data"?: EffectScript; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptReplaceByIdPostEffectScriptsidReplace");
        }
        const baseUrl = `/EffectScripts/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    effectScriptReplaceByIdPutEffectScriptsid(params: {  "id": string; "data"?: EffectScript; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling effectScriptReplaceByIdPutEffectScriptsid");
        }
        const baseUrl = `/EffectScripts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    effectScriptReplaceOrCreatePostEffectScriptsReplaceOrCreate(params: {  "data"?: EffectScript; }, options?: any): FetchArgs {
        const baseUrl = `/EffectScripts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    effectScriptReplaceOrCreatePutEffectScripts(params: {  "data"?: EffectScript; }, options?: any): FetchArgs {
        const baseUrl = `/EffectScripts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    effectScriptUpdateAll(params: {  "where"?: string; "data"?: EffectScript; }, options?: any): FetchArgs {
        const baseUrl = `/EffectScripts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    effectScriptUpsertWithWhere(params: {  "where"?: string; "data"?: EffectScript; }, options?: any): FetchArgs {
        const baseUrl = `/EffectScripts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * EffectScriptApi - functional programming interface
 */
export const EffectScriptApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    effectScriptCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    effectScriptCreate(params: { "data"?: EffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    effectScriptCreateChangeStreamGetEffectScriptsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptCreateChangeStreamGetEffectScriptsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    effectScriptCreateChangeStreamPostEffectScriptsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptCreateChangeStreamPostEffectScriptsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    effectScriptDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    effectScriptExistsGetEffectScriptsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptExistsGetEffectScriptsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    effectScriptExistsHeadEffectScriptsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptExistsHeadEffectScriptsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    effectScriptFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EffectScript>> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    effectScriptFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    effectScriptFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    effectScriptPatchOrCreate(params: { "data"?: EffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts accounts of EffectScript.
     * @param id EffectScript id
     * @param where Criteria to match model instances
     */
    effectScriptPrototypeCountAccounts(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptPrototypeCountAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts histories of EffectScript.
     * @param id EffectScript id
     * @param where Criteria to match model instances
     */
    effectScriptPrototypeCountHistories(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptPrototypeCountHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in accounts of this model.
     * @param id EffectScript id
     * @param data 
     */
    effectScriptPrototypeCreateAccounts(params: { "id": string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptPrototypeCreateAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in histories of this model.
     * @param id EffectScript id
     * @param data 
     */
    effectScriptPrototypeCreateHistories(params: { "id": string; "data"?: History;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptPrototypeCreateHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all accounts of this model.
     * @param id EffectScript id
     */
    effectScriptPrototypeDeleteAccounts(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptPrototypeDeleteAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all histories of this model.
     * @param id EffectScript id
     */
    effectScriptPrototypeDeleteHistories(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptPrototypeDeleteHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accounts.
     * @param id EffectScript id
     * @param fk Foreign key for accounts
     */
    effectScriptPrototypeDestroyByIdAccounts(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptPrototypeDestroyByIdAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for histories.
     * @param id EffectScript id
     * @param fk Foreign key for histories
     */
    effectScriptPrototypeDestroyByIdHistories(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptPrototypeDestroyByIdHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check the existence of accounts relation to an item by id.
     * @param id EffectScript id
     * @param fk Foreign key for accounts
     */
    effectScriptPrototypeExistsAccounts(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptPrototypeExistsAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for accounts.
     * @param id EffectScript id
     * @param fk Foreign key for accounts
     */
    effectScriptPrototypeFindByIdAccounts(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptPrototypeFindByIdAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for histories.
     * @param id EffectScript id
     * @param fk Foreign key for histories
     */
    effectScriptPrototypeFindByIdHistories(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptPrototypeFindByIdHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries accounts of EffectScript.
     * @param id EffectScript id
     * @param filter 
     */
    effectScriptPrototypeGetAccounts(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Account>> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptPrototypeGetAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries histories of EffectScript.
     * @param id EffectScript id
     * @param filter 
     */
    effectScriptPrototypeGetHistories(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<History>> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptPrototypeGetHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id EffectScript id
     * @param nk Foreign key for histories.
     * @param refresh 
     */
    effectScriptPrototypeGetHistoriesAccount(params: { "id": string; "nk": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptPrototypeGetHistoriesAccount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation effectScript.
     * @param id EffectScript id
     * @param nk Foreign key for histories.
     * @param refresh 
     */
    effectScriptPrototypeGetHistoriesEffectScript(params: { "id": string; "nk": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptPrototypeGetHistoriesEffectScript(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Add a related item by id for accounts.
     * @param id EffectScript id
     * @param fk Foreign key for accounts
     * @param data 
     */
    effectScriptPrototypeLinkAccounts(params: { "id": string; "fk": string; "data"?: PayEffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayEffectScript> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptPrototypeLinkAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id EffectScript id
     * @param data An object of model property name/value pairs
     */
    effectScriptPrototypePatchAttributes(params: { "id": string; "data"?: EffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Remove the accounts relation to an item by id.
     * @param id EffectScript id
     * @param fk Foreign key for accounts
     */
    effectScriptPrototypeUnlinkAccounts(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptPrototypeUnlinkAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for accounts.
     * @param id EffectScript id
     * @param fk Foreign key for accounts
     * @param data 
     */
    effectScriptPrototypeUpdateByIdAccounts(params: { "id": string; "fk": string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptPrototypeUpdateByIdAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for histories.
     * @param id EffectScript id
     * @param fk Foreign key for histories
     * @param data 
     */
    effectScriptPrototypeUpdateByIdHistories(params: { "id": string; "fk": string; "data"?: History;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptPrototypeUpdateByIdHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    effectScriptReplaceByIdPostEffectScriptsidReplace(params: { "id": string; "data"?: EffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptReplaceByIdPostEffectScriptsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    effectScriptReplaceByIdPutEffectScriptsid(params: { "id": string; "data"?: EffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptReplaceByIdPutEffectScriptsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    effectScriptReplaceOrCreatePostEffectScriptsReplaceOrCreate(params: { "data"?: EffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptReplaceOrCreatePostEffectScriptsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    effectScriptReplaceOrCreatePutEffectScripts(params: { "data"?: EffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptReplaceOrCreatePutEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    effectScriptUpdateAll(params: { "where"?: string; "data"?: EffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    effectScriptUpsertWithWhere(params: { "where"?: string; "data"?: EffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = EffectScriptApiFetchParamCreator.effectScriptUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * EffectScriptApi - object-oriented interface
 */
export class EffectScriptApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    effectScriptCount(params: {  "where"?: string; }, options?: any) {
        return EffectScriptApiFp.effectScriptCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    effectScriptCreate(params: {  "data"?: EffectScript; }, options?: any) {
        return EffectScriptApiFp.effectScriptCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    effectScriptCreateChangeStreamGetEffectScriptsChangeStream(params: {  "options"?: string; }, options?: any) {
        return EffectScriptApiFp.effectScriptCreateChangeStreamGetEffectScriptsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    effectScriptCreateChangeStreamPostEffectScriptsChangeStream(params: {  "options"?: string; }, options?: any) {
        return EffectScriptApiFp.effectScriptCreateChangeStreamPostEffectScriptsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    effectScriptDeleteById(params: {  "id": string; }, options?: any) {
        return EffectScriptApiFp.effectScriptDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    effectScriptExistsGetEffectScriptsidExists(params: {  "id": string; }, options?: any) {
        return EffectScriptApiFp.effectScriptExistsGetEffectScriptsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    effectScriptExistsHeadEffectScriptsid(params: {  "id": string; }, options?: any) {
        return EffectScriptApiFp.effectScriptExistsHeadEffectScriptsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    effectScriptFind(params: {  "filter"?: string; }, options?: any) {
        return EffectScriptApiFp.effectScriptFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    effectScriptFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return EffectScriptApiFp.effectScriptFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    effectScriptFindOne(params: {  "filter"?: string; }, options?: any) {
        return EffectScriptApiFp.effectScriptFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    effectScriptPatchOrCreate(params: {  "data"?: EffectScript; }, options?: any) {
        return EffectScriptApiFp.effectScriptPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts accounts of EffectScript.
     * @param id EffectScript id
     * @param where Criteria to match model instances
     */
    effectScriptPrototypeCountAccounts(params: {  "id": string; "where"?: string; }, options?: any) {
        return EffectScriptApiFp.effectScriptPrototypeCountAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts histories of EffectScript.
     * @param id EffectScript id
     * @param where Criteria to match model instances
     */
    effectScriptPrototypeCountHistories(params: {  "id": string; "where"?: string; }, options?: any) {
        return EffectScriptApiFp.effectScriptPrototypeCountHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in accounts of this model.
     * @param id EffectScript id
     * @param data 
     */
    effectScriptPrototypeCreateAccounts(params: {  "id": string; "data"?: Account; }, options?: any) {
        return EffectScriptApiFp.effectScriptPrototypeCreateAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in histories of this model.
     * @param id EffectScript id
     * @param data 
     */
    effectScriptPrototypeCreateHistories(params: {  "id": string; "data"?: History; }, options?: any) {
        return EffectScriptApiFp.effectScriptPrototypeCreateHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all accounts of this model.
     * @param id EffectScript id
     */
    effectScriptPrototypeDeleteAccounts(params: {  "id": string; }, options?: any) {
        return EffectScriptApiFp.effectScriptPrototypeDeleteAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all histories of this model.
     * @param id EffectScript id
     */
    effectScriptPrototypeDeleteHistories(params: {  "id": string; }, options?: any) {
        return EffectScriptApiFp.effectScriptPrototypeDeleteHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for accounts.
     * @param id EffectScript id
     * @param fk Foreign key for accounts
     */
    effectScriptPrototypeDestroyByIdAccounts(params: {  "id": string; "fk": string; }, options?: any) {
        return EffectScriptApiFp.effectScriptPrototypeDestroyByIdAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for histories.
     * @param id EffectScript id
     * @param fk Foreign key for histories
     */
    effectScriptPrototypeDestroyByIdHistories(params: {  "id": string; "fk": string; }, options?: any) {
        return EffectScriptApiFp.effectScriptPrototypeDestroyByIdHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check the existence of accounts relation to an item by id.
     * @param id EffectScript id
     * @param fk Foreign key for accounts
     */
    effectScriptPrototypeExistsAccounts(params: {  "id": string; "fk": string; }, options?: any) {
        return EffectScriptApiFp.effectScriptPrototypeExistsAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for accounts.
     * @param id EffectScript id
     * @param fk Foreign key for accounts
     */
    effectScriptPrototypeFindByIdAccounts(params: {  "id": string; "fk": string; }, options?: any) {
        return EffectScriptApiFp.effectScriptPrototypeFindByIdAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for histories.
     * @param id EffectScript id
     * @param fk Foreign key for histories
     */
    effectScriptPrototypeFindByIdHistories(params: {  "id": string; "fk": string; }, options?: any) {
        return EffectScriptApiFp.effectScriptPrototypeFindByIdHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries accounts of EffectScript.
     * @param id EffectScript id
     * @param filter 
     */
    effectScriptPrototypeGetAccounts(params: {  "id": string; "filter"?: string; }, options?: any) {
        return EffectScriptApiFp.effectScriptPrototypeGetAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries histories of EffectScript.
     * @param id EffectScript id
     * @param filter 
     */
    effectScriptPrototypeGetHistories(params: {  "id": string; "filter"?: string; }, options?: any) {
        return EffectScriptApiFp.effectScriptPrototypeGetHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id EffectScript id
     * @param nk Foreign key for histories.
     * @param refresh 
     */
    effectScriptPrototypeGetHistoriesAccount(params: {  "id": string; "nk": string; "refresh"?: boolean; }, options?: any) {
        return EffectScriptApiFp.effectScriptPrototypeGetHistoriesAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation effectScript.
     * @param id EffectScript id
     * @param nk Foreign key for histories.
     * @param refresh 
     */
    effectScriptPrototypeGetHistoriesEffectScript(params: {  "id": string; "nk": string; "refresh"?: boolean; }, options?: any) {
        return EffectScriptApiFp.effectScriptPrototypeGetHistoriesEffectScript(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Add a related item by id for accounts.
     * @param id EffectScript id
     * @param fk Foreign key for accounts
     * @param data 
     */
    effectScriptPrototypeLinkAccounts(params: {  "id": string; "fk": string; "data"?: PayEffectScript; }, options?: any) {
        return EffectScriptApiFp.effectScriptPrototypeLinkAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id EffectScript id
     * @param data An object of model property name/value pairs
     */
    effectScriptPrototypePatchAttributes(params: {  "id": string; "data"?: EffectScript; }, options?: any) {
        return EffectScriptApiFp.effectScriptPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Remove the accounts relation to an item by id.
     * @param id EffectScript id
     * @param fk Foreign key for accounts
     */
    effectScriptPrototypeUnlinkAccounts(params: {  "id": string; "fk": string; }, options?: any) {
        return EffectScriptApiFp.effectScriptPrototypeUnlinkAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for accounts.
     * @param id EffectScript id
     * @param fk Foreign key for accounts
     * @param data 
     */
    effectScriptPrototypeUpdateByIdAccounts(params: {  "id": string; "fk": string; "data"?: Account; }, options?: any) {
        return EffectScriptApiFp.effectScriptPrototypeUpdateByIdAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for histories.
     * @param id EffectScript id
     * @param fk Foreign key for histories
     * @param data 
     */
    effectScriptPrototypeUpdateByIdHistories(params: {  "id": string; "fk": string; "data"?: History; }, options?: any) {
        return EffectScriptApiFp.effectScriptPrototypeUpdateByIdHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    effectScriptReplaceByIdPostEffectScriptsidReplace(params: {  "id": string; "data"?: EffectScript; }, options?: any) {
        return EffectScriptApiFp.effectScriptReplaceByIdPostEffectScriptsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    effectScriptReplaceByIdPutEffectScriptsid(params: {  "id": string; "data"?: EffectScript; }, options?: any) {
        return EffectScriptApiFp.effectScriptReplaceByIdPutEffectScriptsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    effectScriptReplaceOrCreatePostEffectScriptsReplaceOrCreate(params: {  "data"?: EffectScript; }, options?: any) {
        return EffectScriptApiFp.effectScriptReplaceOrCreatePostEffectScriptsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    effectScriptReplaceOrCreatePutEffectScripts(params: {  "data"?: EffectScript; }, options?: any) {
        return EffectScriptApiFp.effectScriptReplaceOrCreatePutEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    effectScriptUpdateAll(params: {  "where"?: string; "data"?: EffectScript; }, options?: any) {
        return EffectScriptApiFp.effectScriptUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    effectScriptUpsertWithWhere(params: {  "where"?: string; "data"?: EffectScript; }, options?: any) {
        return EffectScriptApiFp.effectScriptUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * EffectScriptApi - factory interface
 */
export const EffectScriptApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        effectScriptCount(params: {  "where"?: string; }, options?: any) {
            return EffectScriptApiFp.effectScriptCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        effectScriptCreate(params: {  "data"?: EffectScript; }, options?: any) {
            return EffectScriptApiFp.effectScriptCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        effectScriptCreateChangeStreamGetEffectScriptsChangeStream(params: {  "options"?: string; }, options?: any) {
            return EffectScriptApiFp.effectScriptCreateChangeStreamGetEffectScriptsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        effectScriptCreateChangeStreamPostEffectScriptsChangeStream(params: {  "options"?: string; }, options?: any) {
            return EffectScriptApiFp.effectScriptCreateChangeStreamPostEffectScriptsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        effectScriptDeleteById(params: {  "id": string; }, options?: any) {
            return EffectScriptApiFp.effectScriptDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        effectScriptExistsGetEffectScriptsidExists(params: {  "id": string; }, options?: any) {
            return EffectScriptApiFp.effectScriptExistsGetEffectScriptsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        effectScriptExistsHeadEffectScriptsid(params: {  "id": string; }, options?: any) {
            return EffectScriptApiFp.effectScriptExistsHeadEffectScriptsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        effectScriptFind(params: {  "filter"?: string; }, options?: any) {
            return EffectScriptApiFp.effectScriptFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        effectScriptFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return EffectScriptApiFp.effectScriptFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        effectScriptFindOne(params: {  "filter"?: string; }, options?: any) {
            return EffectScriptApiFp.effectScriptFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        effectScriptPatchOrCreate(params: {  "data"?: EffectScript; }, options?: any) {
            return EffectScriptApiFp.effectScriptPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts accounts of EffectScript.
         * @param id EffectScript id
         * @param where Criteria to match model instances
         */
        effectScriptPrototypeCountAccounts(params: {  "id": string; "where"?: string; }, options?: any) {
            return EffectScriptApiFp.effectScriptPrototypeCountAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts histories of EffectScript.
         * @param id EffectScript id
         * @param where Criteria to match model instances
         */
        effectScriptPrototypeCountHistories(params: {  "id": string; "where"?: string; }, options?: any) {
            return EffectScriptApiFp.effectScriptPrototypeCountHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in accounts of this model.
         * @param id EffectScript id
         * @param data 
         */
        effectScriptPrototypeCreateAccounts(params: {  "id": string; "data"?: Account; }, options?: any) {
            return EffectScriptApiFp.effectScriptPrototypeCreateAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in histories of this model.
         * @param id EffectScript id
         * @param data 
         */
        effectScriptPrototypeCreateHistories(params: {  "id": string; "data"?: History; }, options?: any) {
            return EffectScriptApiFp.effectScriptPrototypeCreateHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all accounts of this model.
         * @param id EffectScript id
         */
        effectScriptPrototypeDeleteAccounts(params: {  "id": string; }, options?: any) {
            return EffectScriptApiFp.effectScriptPrototypeDeleteAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all histories of this model.
         * @param id EffectScript id
         */
        effectScriptPrototypeDeleteHistories(params: {  "id": string; }, options?: any) {
            return EffectScriptApiFp.effectScriptPrototypeDeleteHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for accounts.
         * @param id EffectScript id
         * @param fk Foreign key for accounts
         */
        effectScriptPrototypeDestroyByIdAccounts(params: {  "id": string; "fk": string; }, options?: any) {
            return EffectScriptApiFp.effectScriptPrototypeDestroyByIdAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for histories.
         * @param id EffectScript id
         * @param fk Foreign key for histories
         */
        effectScriptPrototypeDestroyByIdHistories(params: {  "id": string; "fk": string; }, options?: any) {
            return EffectScriptApiFp.effectScriptPrototypeDestroyByIdHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check the existence of accounts relation to an item by id.
         * @param id EffectScript id
         * @param fk Foreign key for accounts
         */
        effectScriptPrototypeExistsAccounts(params: {  "id": string; "fk": string; }, options?: any) {
            return EffectScriptApiFp.effectScriptPrototypeExistsAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for accounts.
         * @param id EffectScript id
         * @param fk Foreign key for accounts
         */
        effectScriptPrototypeFindByIdAccounts(params: {  "id": string; "fk": string; }, options?: any) {
            return EffectScriptApiFp.effectScriptPrototypeFindByIdAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for histories.
         * @param id EffectScript id
         * @param fk Foreign key for histories
         */
        effectScriptPrototypeFindByIdHistories(params: {  "id": string; "fk": string; }, options?: any) {
            return EffectScriptApiFp.effectScriptPrototypeFindByIdHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries accounts of EffectScript.
         * @param id EffectScript id
         * @param filter 
         */
        effectScriptPrototypeGetAccounts(params: {  "id": string; "filter"?: string; }, options?: any) {
            return EffectScriptApiFp.effectScriptPrototypeGetAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries histories of EffectScript.
         * @param id EffectScript id
         * @param filter 
         */
        effectScriptPrototypeGetHistories(params: {  "id": string; "filter"?: string; }, options?: any) {
            return EffectScriptApiFp.effectScriptPrototypeGetHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation account.
         * @param id EffectScript id
         * @param nk Foreign key for histories.
         * @param refresh 
         */
        effectScriptPrototypeGetHistoriesAccount(params: {  "id": string; "nk": string; "refresh"?: boolean; }, options?: any) {
            return EffectScriptApiFp.effectScriptPrototypeGetHistoriesAccount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation effectScript.
         * @param id EffectScript id
         * @param nk Foreign key for histories.
         * @param refresh 
         */
        effectScriptPrototypeGetHistoriesEffectScript(params: {  "id": string; "nk": string; "refresh"?: boolean; }, options?: any) {
            return EffectScriptApiFp.effectScriptPrototypeGetHistoriesEffectScript(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add a related item by id for accounts.
         * @param id EffectScript id
         * @param fk Foreign key for accounts
         * @param data 
         */
        effectScriptPrototypeLinkAccounts(params: {  "id": string; "fk": string; "data"?: PayEffectScript; }, options?: any) {
            return EffectScriptApiFp.effectScriptPrototypeLinkAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id EffectScript id
         * @param data An object of model property name/value pairs
         */
        effectScriptPrototypePatchAttributes(params: {  "id": string; "data"?: EffectScript; }, options?: any) {
            return EffectScriptApiFp.effectScriptPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the accounts relation to an item by id.
         * @param id EffectScript id
         * @param fk Foreign key for accounts
         */
        effectScriptPrototypeUnlinkAccounts(params: {  "id": string; "fk": string; }, options?: any) {
            return EffectScriptApiFp.effectScriptPrototypeUnlinkAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for accounts.
         * @param id EffectScript id
         * @param fk Foreign key for accounts
         * @param data 
         */
        effectScriptPrototypeUpdateByIdAccounts(params: {  "id": string; "fk": string; "data"?: Account; }, options?: any) {
            return EffectScriptApiFp.effectScriptPrototypeUpdateByIdAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for histories.
         * @param id EffectScript id
         * @param fk Foreign key for histories
         * @param data 
         */
        effectScriptPrototypeUpdateByIdHistories(params: {  "id": string; "fk": string; "data"?: History; }, options?: any) {
            return EffectScriptApiFp.effectScriptPrototypeUpdateByIdHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        effectScriptReplaceByIdPostEffectScriptsidReplace(params: {  "id": string; "data"?: EffectScript; }, options?: any) {
            return EffectScriptApiFp.effectScriptReplaceByIdPostEffectScriptsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        effectScriptReplaceByIdPutEffectScriptsid(params: {  "id": string; "data"?: EffectScript; }, options?: any) {
            return EffectScriptApiFp.effectScriptReplaceByIdPutEffectScriptsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        effectScriptReplaceOrCreatePostEffectScriptsReplaceOrCreate(params: {  "data"?: EffectScript; }, options?: any) {
            return EffectScriptApiFp.effectScriptReplaceOrCreatePostEffectScriptsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        effectScriptReplaceOrCreatePutEffectScripts(params: {  "data"?: EffectScript; }, options?: any) {
            return EffectScriptApiFp.effectScriptReplaceOrCreatePutEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        effectScriptUpdateAll(params: {  "where"?: string; "data"?: EffectScript; }, options?: any) {
            return EffectScriptApiFp.effectScriptUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        effectScriptUpsertWithWhere(params: {  "where"?: string; "data"?: EffectScript; }, options?: any) {
            return EffectScriptApiFp.effectScriptUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * HistoryApi - fetch parameter creator
 */
export const HistoryApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    historyCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Histories/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    historyCreate(params: {  "data"?: History; }, options?: any): FetchArgs {
        const baseUrl = `/Histories`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    historyCreateChangeStreamGetHistoriesChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Histories/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    historyCreateChangeStreamPostHistoriesChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Histories/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    historyDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyDeleteById");
        }
        const baseUrl = `/Histories/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    historyExistsGetHistoriesidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyExistsGetHistoriesidExists");
        }
        const baseUrl = `/Histories/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    historyExistsHeadHistoriesid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyExistsHeadHistoriesid");
        }
        const baseUrl = `/Histories/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    historyFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Histories`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    historyFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyFindById");
        }
        const baseUrl = `/Histories/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    historyFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Histories/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    historyPatchOrCreate(params: {  "data"?: History; }, options?: any): FetchArgs {
        const baseUrl = `/Histories`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts accessTokens of Account.
     * @param id History id
     * @param where Criteria to match model instances
     */
    historyPrototypeCountAccountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeCountAccountAccessTokens");
        }
        const baseUrl = `/Histories/{id}/account/accessTokens/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts effectScripts of Account.
     * @param id History id
     * @param where Criteria to match model instances
     */
    historyPrototypeCountAccountEffectScripts(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeCountAccountEffectScripts");
        }
        const baseUrl = `/Histories/{id}/account/effectScripts/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts histories of Account.
     * @param id History id
     * @param where Criteria to match model instances
     */
    historyPrototypeCountAccountHistories(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeCountAccountHistories");
        }
        const baseUrl = `/Histories/{id}/account/histories/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts accounts of EffectScript.
     * @param id History id
     * @param where Criteria to match model instances
     */
    historyPrototypeCountEffectScriptAccounts(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeCountEffectScriptAccounts");
        }
        const baseUrl = `/Histories/{id}/effectScript/accounts/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts histories of EffectScript.
     * @param id History id
     * @param where Criteria to match model instances
     */
    historyPrototypeCountEffectScriptHistories(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeCountEffectScriptHistories");
        }
        const baseUrl = `/Histories/{id}/effectScript/histories/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id History id
     * @param data 
     */
    historyPrototypeCreateAccountAccessTokens(params: {  "id": string; "data"?: AccessToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeCreateAccountAccessTokens");
        }
        const baseUrl = `/Histories/{id}/account/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in effectScripts of this model.
     * @param id History id
     * @param data 
     */
    historyPrototypeCreateAccountEffectScripts(params: {  "id": string; "data"?: EffectScript; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeCreateAccountEffectScripts");
        }
        const baseUrl = `/Histories/{id}/account/effectScripts`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in histories of this model.
     * @param id History id
     * @param data 
     */
    historyPrototypeCreateAccountHistories(params: {  "id": string; "data"?: History; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeCreateAccountHistories");
        }
        const baseUrl = `/Histories/{id}/account/histories`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in accounts of this model.
     * @param id History id
     * @param data 
     */
    historyPrototypeCreateEffectScriptAccounts(params: {  "id": string; "data"?: Account; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeCreateEffectScriptAccounts");
        }
        const baseUrl = `/Histories/{id}/effectScript/accounts`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in histories of this model.
     * @param id History id
     * @param data 
     */
    historyPrototypeCreateEffectScriptHistories(params: {  "id": string; "data"?: History; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeCreateEffectScriptHistories");
        }
        const baseUrl = `/Histories/{id}/effectScript/histories`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id History id
     */
    historyPrototypeDeleteAccountAccessTokens(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeDeleteAccountAccessTokens");
        }
        const baseUrl = `/Histories/{id}/account/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all effectScripts of this model.
     * @param id History id
     */
    historyPrototypeDeleteAccountEffectScripts(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeDeleteAccountEffectScripts");
        }
        const baseUrl = `/Histories/{id}/account/effectScripts`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all histories of this model.
     * @param id History id
     */
    historyPrototypeDeleteAccountHistories(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeDeleteAccountHistories");
        }
        const baseUrl = `/Histories/{id}/account/histories`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all accounts of this model.
     * @param id History id
     */
    historyPrototypeDeleteEffectScriptAccounts(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeDeleteEffectScriptAccounts");
        }
        const baseUrl = `/Histories/{id}/effectScript/accounts`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all histories of this model.
     * @param id History id
     */
    historyPrototypeDeleteEffectScriptHistories(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeDeleteEffectScriptHistories");
        }
        const baseUrl = `/Histories/{id}/effectScript/histories`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id History id
     * @param fk Foreign key for accessTokens
     */
    historyPrototypeDestroyByIdAccountAccessTokens(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeDestroyByIdAccountAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling historyPrototypeDestroyByIdAccountAccessTokens");
        }
        const baseUrl = `/Histories/{id}/account/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for effectScripts.
     * @param id History id
     * @param fk Foreign key for effectScripts
     */
    historyPrototypeDestroyByIdAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeDestroyByIdAccountEffectScripts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling historyPrototypeDestroyByIdAccountEffectScripts");
        }
        const baseUrl = `/Histories/{id}/account/effectScripts/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for histories.
     * @param id History id
     * @param fk Foreign key for histories
     */
    historyPrototypeDestroyByIdAccountHistories(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeDestroyByIdAccountHistories");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling historyPrototypeDestroyByIdAccountHistories");
        }
        const baseUrl = `/Histories/{id}/account/histories/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accounts.
     * @param id History id
     * @param fk Foreign key for accounts
     */
    historyPrototypeDestroyByIdEffectScriptAccounts(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeDestroyByIdEffectScriptAccounts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling historyPrototypeDestroyByIdEffectScriptAccounts");
        }
        const baseUrl = `/Histories/{id}/effectScript/accounts/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for histories.
     * @param id History id
     * @param fk Foreign key for histories
     */
    historyPrototypeDestroyByIdEffectScriptHistories(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeDestroyByIdEffectScriptHistories");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling historyPrototypeDestroyByIdEffectScriptHistories");
        }
        const baseUrl = `/Histories/{id}/effectScript/histories/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check the existence of effectScripts relation to an item by id.
     * @param id History id
     * @param fk Foreign key for effectScripts
     */
    historyPrototypeExistsAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeExistsAccountEffectScripts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling historyPrototypeExistsAccountEffectScripts");
        }
        const baseUrl = `/Histories/{id}/account/effectScripts/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check the existence of accounts relation to an item by id.
     * @param id History id
     * @param fk Foreign key for accounts
     */
    historyPrototypeExistsEffectScriptAccounts(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeExistsEffectScriptAccounts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling historyPrototypeExistsEffectScriptAccounts");
        }
        const baseUrl = `/Histories/{id}/effectScript/accounts/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id History id
     * @param fk Foreign key for accessTokens
     */
    historyPrototypeFindByIdAccountAccessTokens(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeFindByIdAccountAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling historyPrototypeFindByIdAccountAccessTokens");
        }
        const baseUrl = `/Histories/{id}/account/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for effectScripts.
     * @param id History id
     * @param fk Foreign key for effectScripts
     */
    historyPrototypeFindByIdAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeFindByIdAccountEffectScripts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling historyPrototypeFindByIdAccountEffectScripts");
        }
        const baseUrl = `/Histories/{id}/account/effectScripts/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for histories.
     * @param id History id
     * @param fk Foreign key for histories
     */
    historyPrototypeFindByIdAccountHistories(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeFindByIdAccountHistories");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling historyPrototypeFindByIdAccountHistories");
        }
        const baseUrl = `/Histories/{id}/account/histories/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for accounts.
     * @param id History id
     * @param fk Foreign key for accounts
     */
    historyPrototypeFindByIdEffectScriptAccounts(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeFindByIdEffectScriptAccounts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling historyPrototypeFindByIdEffectScriptAccounts");
        }
        const baseUrl = `/Histories/{id}/effectScript/accounts/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for histories.
     * @param id History id
     * @param fk Foreign key for histories
     */
    historyPrototypeFindByIdEffectScriptHistories(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeFindByIdEffectScriptHistories");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling historyPrototypeFindByIdEffectScriptHistories");
        }
        const baseUrl = `/Histories/{id}/effectScript/histories/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id History id
     * @param refresh 
     */
    historyPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeGetAccount");
        }
        const baseUrl = `/Histories/{id}/account`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries accessTokens of Account.
     * @param id History id
     * @param filter 
     */
    historyPrototypeGetAccountAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeGetAccountAccessTokens");
        }
        const baseUrl = `/Histories/{id}/account/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries effectScripts of Account.
     * @param id History id
     * @param filter 
     */
    historyPrototypeGetAccountEffectScripts(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeGetAccountEffectScripts");
        }
        const baseUrl = `/Histories/{id}/account/effectScripts`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries histories of Account.
     * @param id History id
     * @param filter 
     */
    historyPrototypeGetAccountHistories(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeGetAccountHistories");
        }
        const baseUrl = `/Histories/{id}/account/histories`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation effectScript.
     * @param id History id
     * @param refresh 
     */
    historyPrototypeGetEffectScript(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeGetEffectScript");
        }
        const baseUrl = `/Histories/{id}/effectScript`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries accounts of EffectScript.
     * @param id History id
     * @param filter 
     */
    historyPrototypeGetEffectScriptAccounts(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeGetEffectScriptAccounts");
        }
        const baseUrl = `/Histories/{id}/effectScript/accounts`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries histories of EffectScript.
     * @param id History id
     * @param filter 
     */
    historyPrototypeGetEffectScriptHistories(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeGetEffectScriptHistories");
        }
        const baseUrl = `/Histories/{id}/effectScript/histories`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Add a related item by id for effectScripts.
     * @param id History id
     * @param fk Foreign key for effectScripts
     * @param data 
     */
    historyPrototypeLinkAccountEffectScripts(params: {  "id": string; "fk": string; "data"?: PayEffectScript; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeLinkAccountEffectScripts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling historyPrototypeLinkAccountEffectScripts");
        }
        const baseUrl = `/Histories/{id}/account/effectScripts/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Add a related item by id for accounts.
     * @param id History id
     * @param fk Foreign key for accounts
     * @param data 
     */
    historyPrototypeLinkEffectScriptAccounts(params: {  "id": string; "fk": string; "data"?: PayEffectScript; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeLinkEffectScriptAccounts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling historyPrototypeLinkEffectScriptAccounts");
        }
        const baseUrl = `/Histories/{id}/effectScript/accounts/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id History id
     * @param data An object of model property name/value pairs
     */
    historyPrototypePatchAttributes(params: {  "id": string; "data"?: History; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypePatchAttributes");
        }
        const baseUrl = `/Histories/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Remove the effectScripts relation to an item by id.
     * @param id History id
     * @param fk Foreign key for effectScripts
     */
    historyPrototypeUnlinkAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeUnlinkAccountEffectScripts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling historyPrototypeUnlinkAccountEffectScripts");
        }
        const baseUrl = `/Histories/{id}/account/effectScripts/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Remove the accounts relation to an item by id.
     * @param id History id
     * @param fk Foreign key for accounts
     */
    historyPrototypeUnlinkEffectScriptAccounts(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeUnlinkEffectScriptAccounts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling historyPrototypeUnlinkEffectScriptAccounts");
        }
        const baseUrl = `/Histories/{id}/effectScript/accounts/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id History id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    historyPrototypeUpdateByIdAccountAccessTokens(params: {  "id": string; "fk": string; "data"?: AccessToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeUpdateByIdAccountAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling historyPrototypeUpdateByIdAccountAccessTokens");
        }
        const baseUrl = `/Histories/{id}/account/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for effectScripts.
     * @param id History id
     * @param fk Foreign key for effectScripts
     * @param data 
     */
    historyPrototypeUpdateByIdAccountEffectScripts(params: {  "id": string; "fk": string; "data"?: EffectScript; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeUpdateByIdAccountEffectScripts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling historyPrototypeUpdateByIdAccountEffectScripts");
        }
        const baseUrl = `/Histories/{id}/account/effectScripts/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for histories.
     * @param id History id
     * @param fk Foreign key for histories
     * @param data 
     */
    historyPrototypeUpdateByIdAccountHistories(params: {  "id": string; "fk": string; "data"?: History; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeUpdateByIdAccountHistories");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling historyPrototypeUpdateByIdAccountHistories");
        }
        const baseUrl = `/Histories/{id}/account/histories/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for accounts.
     * @param id History id
     * @param fk Foreign key for accounts
     * @param data 
     */
    historyPrototypeUpdateByIdEffectScriptAccounts(params: {  "id": string; "fk": string; "data"?: Account; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeUpdateByIdEffectScriptAccounts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling historyPrototypeUpdateByIdEffectScriptAccounts");
        }
        const baseUrl = `/Histories/{id}/effectScript/accounts/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for histories.
     * @param id History id
     * @param fk Foreign key for histories
     * @param data 
     */
    historyPrototypeUpdateByIdEffectScriptHistories(params: {  "id": string; "fk": string; "data"?: History; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyPrototypeUpdateByIdEffectScriptHistories");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling historyPrototypeUpdateByIdEffectScriptHistories");
        }
        const baseUrl = `/Histories/{id}/effectScript/histories/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    historyReplaceByIdPostHistoriesidReplace(params: {  "id": string; "data"?: History; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyReplaceByIdPostHistoriesidReplace");
        }
        const baseUrl = `/Histories/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    historyReplaceByIdPutHistoriesid(params: {  "id": string; "data"?: History; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling historyReplaceByIdPutHistoriesid");
        }
        const baseUrl = `/Histories/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    historyReplaceOrCreatePostHistoriesReplaceOrCreate(params: {  "data"?: History; }, options?: any): FetchArgs {
        const baseUrl = `/Histories/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    historyReplaceOrCreatePutHistories(params: {  "data"?: History; }, options?: any): FetchArgs {
        const baseUrl = `/Histories`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    historyUpdateAll(params: {  "where"?: string; "data"?: History; }, options?: any): FetchArgs {
        const baseUrl = `/Histories/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    historyUpsertWithWhere(params: {  "where"?: string; "data"?: History; }, options?: any): FetchArgs {
        const baseUrl = `/Histories/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * HistoryApi - functional programming interface
 */
export const HistoryApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    historyCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = HistoryApiFetchParamCreator.historyCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    historyCreate(params: { "data"?: History;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = HistoryApiFetchParamCreator.historyCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    historyCreateChangeStreamGetHistoriesChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = HistoryApiFetchParamCreator.historyCreateChangeStreamGetHistoriesChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    historyCreateChangeStreamPostHistoriesChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = HistoryApiFetchParamCreator.historyCreateChangeStreamPostHistoriesChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    historyDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = HistoryApiFetchParamCreator.historyDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    historyExistsGetHistoriesidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = HistoryApiFetchParamCreator.historyExistsGetHistoriesidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    historyExistsHeadHistoriesid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = HistoryApiFetchParamCreator.historyExistsHeadHistoriesid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    historyFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<History>> {
        const fetchArgs = HistoryApiFetchParamCreator.historyFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    historyFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = HistoryApiFetchParamCreator.historyFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    historyFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = HistoryApiFetchParamCreator.historyFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    historyPatchOrCreate(params: { "data"?: History;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts accessTokens of Account.
     * @param id History id
     * @param where Criteria to match model instances
     */
    historyPrototypeCountAccountAccessTokens(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeCountAccountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts effectScripts of Account.
     * @param id History id
     * @param where Criteria to match model instances
     */
    historyPrototypeCountAccountEffectScripts(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeCountAccountEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts histories of Account.
     * @param id History id
     * @param where Criteria to match model instances
     */
    historyPrototypeCountAccountHistories(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeCountAccountHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts accounts of EffectScript.
     * @param id History id
     * @param where Criteria to match model instances
     */
    historyPrototypeCountEffectScriptAccounts(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeCountEffectScriptAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts histories of EffectScript.
     * @param id History id
     * @param where Criteria to match model instances
     */
    historyPrototypeCountEffectScriptHistories(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeCountEffectScriptHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id History id
     * @param data 
     */
    historyPrototypeCreateAccountAccessTokens(params: { "id": string; "data"?: AccessToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeCreateAccountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in effectScripts of this model.
     * @param id History id
     * @param data 
     */
    historyPrototypeCreateAccountEffectScripts(params: { "id": string; "data"?: EffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeCreateAccountEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in histories of this model.
     * @param id History id
     * @param data 
     */
    historyPrototypeCreateAccountHistories(params: { "id": string; "data"?: History;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeCreateAccountHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in accounts of this model.
     * @param id History id
     * @param data 
     */
    historyPrototypeCreateEffectScriptAccounts(params: { "id": string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeCreateEffectScriptAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in histories of this model.
     * @param id History id
     * @param data 
     */
    historyPrototypeCreateEffectScriptHistories(params: { "id": string; "data"?: History;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeCreateEffectScriptHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id History id
     */
    historyPrototypeDeleteAccountAccessTokens(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeDeleteAccountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all effectScripts of this model.
     * @param id History id
     */
    historyPrototypeDeleteAccountEffectScripts(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeDeleteAccountEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all histories of this model.
     * @param id History id
     */
    historyPrototypeDeleteAccountHistories(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeDeleteAccountHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all accounts of this model.
     * @param id History id
     */
    historyPrototypeDeleteEffectScriptAccounts(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeDeleteEffectScriptAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all histories of this model.
     * @param id History id
     */
    historyPrototypeDeleteEffectScriptHistories(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeDeleteEffectScriptHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id History id
     * @param fk Foreign key for accessTokens
     */
    historyPrototypeDestroyByIdAccountAccessTokens(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeDestroyByIdAccountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for effectScripts.
     * @param id History id
     * @param fk Foreign key for effectScripts
     */
    historyPrototypeDestroyByIdAccountEffectScripts(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeDestroyByIdAccountEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for histories.
     * @param id History id
     * @param fk Foreign key for histories
     */
    historyPrototypeDestroyByIdAccountHistories(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeDestroyByIdAccountHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accounts.
     * @param id History id
     * @param fk Foreign key for accounts
     */
    historyPrototypeDestroyByIdEffectScriptAccounts(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeDestroyByIdEffectScriptAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for histories.
     * @param id History id
     * @param fk Foreign key for histories
     */
    historyPrototypeDestroyByIdEffectScriptHistories(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeDestroyByIdEffectScriptHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check the existence of effectScripts relation to an item by id.
     * @param id History id
     * @param fk Foreign key for effectScripts
     */
    historyPrototypeExistsAccountEffectScripts(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeExistsAccountEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check the existence of accounts relation to an item by id.
     * @param id History id
     * @param fk Foreign key for accounts
     */
    historyPrototypeExistsEffectScriptAccounts(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeExistsEffectScriptAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id History id
     * @param fk Foreign key for accessTokens
     */
    historyPrototypeFindByIdAccountAccessTokens(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeFindByIdAccountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for effectScripts.
     * @param id History id
     * @param fk Foreign key for effectScripts
     */
    historyPrototypeFindByIdAccountEffectScripts(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeFindByIdAccountEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for histories.
     * @param id History id
     * @param fk Foreign key for histories
     */
    historyPrototypeFindByIdAccountHistories(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeFindByIdAccountHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for accounts.
     * @param id History id
     * @param fk Foreign key for accounts
     */
    historyPrototypeFindByIdEffectScriptAccounts(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeFindByIdEffectScriptAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for histories.
     * @param id History id
     * @param fk Foreign key for histories
     */
    historyPrototypeFindByIdEffectScriptHistories(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeFindByIdEffectScriptHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id History id
     * @param refresh 
     */
    historyPrototypeGetAccount(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeGetAccount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries accessTokens of Account.
     * @param id History id
     * @param filter 
     */
    historyPrototypeGetAccountAccessTokens(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccessToken>> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeGetAccountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries effectScripts of Account.
     * @param id History id
     * @param filter 
     */
    historyPrototypeGetAccountEffectScripts(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EffectScript>> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeGetAccountEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries histories of Account.
     * @param id History id
     * @param filter 
     */
    historyPrototypeGetAccountHistories(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<History>> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeGetAccountHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation effectScript.
     * @param id History id
     * @param refresh 
     */
    historyPrototypeGetEffectScript(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeGetEffectScript(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries accounts of EffectScript.
     * @param id History id
     * @param filter 
     */
    historyPrototypeGetEffectScriptAccounts(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Account>> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeGetEffectScriptAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries histories of EffectScript.
     * @param id History id
     * @param filter 
     */
    historyPrototypeGetEffectScriptHistories(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<History>> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeGetEffectScriptHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Add a related item by id for effectScripts.
     * @param id History id
     * @param fk Foreign key for effectScripts
     * @param data 
     */
    historyPrototypeLinkAccountEffectScripts(params: { "id": string; "fk": string; "data"?: PayEffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayEffectScript> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeLinkAccountEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Add a related item by id for accounts.
     * @param id History id
     * @param fk Foreign key for accounts
     * @param data 
     */
    historyPrototypeLinkEffectScriptAccounts(params: { "id": string; "fk": string; "data"?: PayEffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayEffectScript> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeLinkEffectScriptAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id History id
     * @param data An object of model property name/value pairs
     */
    historyPrototypePatchAttributes(params: { "id": string; "data"?: History;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Remove the effectScripts relation to an item by id.
     * @param id History id
     * @param fk Foreign key for effectScripts
     */
    historyPrototypeUnlinkAccountEffectScripts(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeUnlinkAccountEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Remove the accounts relation to an item by id.
     * @param id History id
     * @param fk Foreign key for accounts
     */
    historyPrototypeUnlinkEffectScriptAccounts(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeUnlinkEffectScriptAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id History id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    historyPrototypeUpdateByIdAccountAccessTokens(params: { "id": string; "fk": string; "data"?: AccessToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeUpdateByIdAccountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for effectScripts.
     * @param id History id
     * @param fk Foreign key for effectScripts
     * @param data 
     */
    historyPrototypeUpdateByIdAccountEffectScripts(params: { "id": string; "fk": string; "data"?: EffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeUpdateByIdAccountEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for histories.
     * @param id History id
     * @param fk Foreign key for histories
     * @param data 
     */
    historyPrototypeUpdateByIdAccountHistories(params: { "id": string; "fk": string; "data"?: History;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeUpdateByIdAccountHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for accounts.
     * @param id History id
     * @param fk Foreign key for accounts
     * @param data 
     */
    historyPrototypeUpdateByIdEffectScriptAccounts(params: { "id": string; "fk": string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeUpdateByIdEffectScriptAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for histories.
     * @param id History id
     * @param fk Foreign key for histories
     * @param data 
     */
    historyPrototypeUpdateByIdEffectScriptHistories(params: { "id": string; "fk": string; "data"?: History;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = HistoryApiFetchParamCreator.historyPrototypeUpdateByIdEffectScriptHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    historyReplaceByIdPostHistoriesidReplace(params: { "id": string; "data"?: History;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = HistoryApiFetchParamCreator.historyReplaceByIdPostHistoriesidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    historyReplaceByIdPutHistoriesid(params: { "id": string; "data"?: History;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = HistoryApiFetchParamCreator.historyReplaceByIdPutHistoriesid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    historyReplaceOrCreatePostHistoriesReplaceOrCreate(params: { "data"?: History;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = HistoryApiFetchParamCreator.historyReplaceOrCreatePostHistoriesReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    historyReplaceOrCreatePutHistories(params: { "data"?: History;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = HistoryApiFetchParamCreator.historyReplaceOrCreatePutHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    historyUpdateAll(params: { "where"?: string; "data"?: History;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = HistoryApiFetchParamCreator.historyUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    historyUpsertWithWhere(params: { "where"?: string; "data"?: History;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = HistoryApiFetchParamCreator.historyUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * HistoryApi - object-oriented interface
 */
export class HistoryApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    historyCount(params: {  "where"?: string; }, options?: any) {
        return HistoryApiFp.historyCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    historyCreate(params: {  "data"?: History; }, options?: any) {
        return HistoryApiFp.historyCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    historyCreateChangeStreamGetHistoriesChangeStream(params: {  "options"?: string; }, options?: any) {
        return HistoryApiFp.historyCreateChangeStreamGetHistoriesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    historyCreateChangeStreamPostHistoriesChangeStream(params: {  "options"?: string; }, options?: any) {
        return HistoryApiFp.historyCreateChangeStreamPostHistoriesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    historyDeleteById(params: {  "id": string; }, options?: any) {
        return HistoryApiFp.historyDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    historyExistsGetHistoriesidExists(params: {  "id": string; }, options?: any) {
        return HistoryApiFp.historyExistsGetHistoriesidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    historyExistsHeadHistoriesid(params: {  "id": string; }, options?: any) {
        return HistoryApiFp.historyExistsHeadHistoriesid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    historyFind(params: {  "filter"?: string; }, options?: any) {
        return HistoryApiFp.historyFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    historyFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return HistoryApiFp.historyFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    historyFindOne(params: {  "filter"?: string; }, options?: any) {
        return HistoryApiFp.historyFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    historyPatchOrCreate(params: {  "data"?: History; }, options?: any) {
        return HistoryApiFp.historyPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts accessTokens of Account.
     * @param id History id
     * @param where Criteria to match model instances
     */
    historyPrototypeCountAccountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any) {
        return HistoryApiFp.historyPrototypeCountAccountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts effectScripts of Account.
     * @param id History id
     * @param where Criteria to match model instances
     */
    historyPrototypeCountAccountEffectScripts(params: {  "id": string; "where"?: string; }, options?: any) {
        return HistoryApiFp.historyPrototypeCountAccountEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts histories of Account.
     * @param id History id
     * @param where Criteria to match model instances
     */
    historyPrototypeCountAccountHistories(params: {  "id": string; "where"?: string; }, options?: any) {
        return HistoryApiFp.historyPrototypeCountAccountHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts accounts of EffectScript.
     * @param id History id
     * @param where Criteria to match model instances
     */
    historyPrototypeCountEffectScriptAccounts(params: {  "id": string; "where"?: string; }, options?: any) {
        return HistoryApiFp.historyPrototypeCountEffectScriptAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts histories of EffectScript.
     * @param id History id
     * @param where Criteria to match model instances
     */
    historyPrototypeCountEffectScriptHistories(params: {  "id": string; "where"?: string; }, options?: any) {
        return HistoryApiFp.historyPrototypeCountEffectScriptHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id History id
     * @param data 
     */
    historyPrototypeCreateAccountAccessTokens(params: {  "id": string; "data"?: AccessToken; }, options?: any) {
        return HistoryApiFp.historyPrototypeCreateAccountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in effectScripts of this model.
     * @param id History id
     * @param data 
     */
    historyPrototypeCreateAccountEffectScripts(params: {  "id": string; "data"?: EffectScript; }, options?: any) {
        return HistoryApiFp.historyPrototypeCreateAccountEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in histories of this model.
     * @param id History id
     * @param data 
     */
    historyPrototypeCreateAccountHistories(params: {  "id": string; "data"?: History; }, options?: any) {
        return HistoryApiFp.historyPrototypeCreateAccountHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in accounts of this model.
     * @param id History id
     * @param data 
     */
    historyPrototypeCreateEffectScriptAccounts(params: {  "id": string; "data"?: Account; }, options?: any) {
        return HistoryApiFp.historyPrototypeCreateEffectScriptAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in histories of this model.
     * @param id History id
     * @param data 
     */
    historyPrototypeCreateEffectScriptHistories(params: {  "id": string; "data"?: History; }, options?: any) {
        return HistoryApiFp.historyPrototypeCreateEffectScriptHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id History id
     */
    historyPrototypeDeleteAccountAccessTokens(params: {  "id": string; }, options?: any) {
        return HistoryApiFp.historyPrototypeDeleteAccountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all effectScripts of this model.
     * @param id History id
     */
    historyPrototypeDeleteAccountEffectScripts(params: {  "id": string; }, options?: any) {
        return HistoryApiFp.historyPrototypeDeleteAccountEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all histories of this model.
     * @param id History id
     */
    historyPrototypeDeleteAccountHistories(params: {  "id": string; }, options?: any) {
        return HistoryApiFp.historyPrototypeDeleteAccountHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all accounts of this model.
     * @param id History id
     */
    historyPrototypeDeleteEffectScriptAccounts(params: {  "id": string; }, options?: any) {
        return HistoryApiFp.historyPrototypeDeleteEffectScriptAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all histories of this model.
     * @param id History id
     */
    historyPrototypeDeleteEffectScriptHistories(params: {  "id": string; }, options?: any) {
        return HistoryApiFp.historyPrototypeDeleteEffectScriptHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id History id
     * @param fk Foreign key for accessTokens
     */
    historyPrototypeDestroyByIdAccountAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
        return HistoryApiFp.historyPrototypeDestroyByIdAccountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for effectScripts.
     * @param id History id
     * @param fk Foreign key for effectScripts
     */
    historyPrototypeDestroyByIdAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
        return HistoryApiFp.historyPrototypeDestroyByIdAccountEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for histories.
     * @param id History id
     * @param fk Foreign key for histories
     */
    historyPrototypeDestroyByIdAccountHistories(params: {  "id": string; "fk": string; }, options?: any) {
        return HistoryApiFp.historyPrototypeDestroyByIdAccountHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for accounts.
     * @param id History id
     * @param fk Foreign key for accounts
     */
    historyPrototypeDestroyByIdEffectScriptAccounts(params: {  "id": string; "fk": string; }, options?: any) {
        return HistoryApiFp.historyPrototypeDestroyByIdEffectScriptAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for histories.
     * @param id History id
     * @param fk Foreign key for histories
     */
    historyPrototypeDestroyByIdEffectScriptHistories(params: {  "id": string; "fk": string; }, options?: any) {
        return HistoryApiFp.historyPrototypeDestroyByIdEffectScriptHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check the existence of effectScripts relation to an item by id.
     * @param id History id
     * @param fk Foreign key for effectScripts
     */
    historyPrototypeExistsAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
        return HistoryApiFp.historyPrototypeExistsAccountEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check the existence of accounts relation to an item by id.
     * @param id History id
     * @param fk Foreign key for accounts
     */
    historyPrototypeExistsEffectScriptAccounts(params: {  "id": string; "fk": string; }, options?: any) {
        return HistoryApiFp.historyPrototypeExistsEffectScriptAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id History id
     * @param fk Foreign key for accessTokens
     */
    historyPrototypeFindByIdAccountAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
        return HistoryApiFp.historyPrototypeFindByIdAccountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for effectScripts.
     * @param id History id
     * @param fk Foreign key for effectScripts
     */
    historyPrototypeFindByIdAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
        return HistoryApiFp.historyPrototypeFindByIdAccountEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for histories.
     * @param id History id
     * @param fk Foreign key for histories
     */
    historyPrototypeFindByIdAccountHistories(params: {  "id": string; "fk": string; }, options?: any) {
        return HistoryApiFp.historyPrototypeFindByIdAccountHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for accounts.
     * @param id History id
     * @param fk Foreign key for accounts
     */
    historyPrototypeFindByIdEffectScriptAccounts(params: {  "id": string; "fk": string; }, options?: any) {
        return HistoryApiFp.historyPrototypeFindByIdEffectScriptAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for histories.
     * @param id History id
     * @param fk Foreign key for histories
     */
    historyPrototypeFindByIdEffectScriptHistories(params: {  "id": string; "fk": string; }, options?: any) {
        return HistoryApiFp.historyPrototypeFindByIdEffectScriptHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id History id
     * @param refresh 
     */
    historyPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return HistoryApiFp.historyPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries accessTokens of Account.
     * @param id History id
     * @param filter 
     */
    historyPrototypeGetAccountAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any) {
        return HistoryApiFp.historyPrototypeGetAccountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries effectScripts of Account.
     * @param id History id
     * @param filter 
     */
    historyPrototypeGetAccountEffectScripts(params: {  "id": string; "filter"?: string; }, options?: any) {
        return HistoryApiFp.historyPrototypeGetAccountEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries histories of Account.
     * @param id History id
     * @param filter 
     */
    historyPrototypeGetAccountHistories(params: {  "id": string; "filter"?: string; }, options?: any) {
        return HistoryApiFp.historyPrototypeGetAccountHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation effectScript.
     * @param id History id
     * @param refresh 
     */
    historyPrototypeGetEffectScript(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return HistoryApiFp.historyPrototypeGetEffectScript(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries accounts of EffectScript.
     * @param id History id
     * @param filter 
     */
    historyPrototypeGetEffectScriptAccounts(params: {  "id": string; "filter"?: string; }, options?: any) {
        return HistoryApiFp.historyPrototypeGetEffectScriptAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries histories of EffectScript.
     * @param id History id
     * @param filter 
     */
    historyPrototypeGetEffectScriptHistories(params: {  "id": string; "filter"?: string; }, options?: any) {
        return HistoryApiFp.historyPrototypeGetEffectScriptHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Add a related item by id for effectScripts.
     * @param id History id
     * @param fk Foreign key for effectScripts
     * @param data 
     */
    historyPrototypeLinkAccountEffectScripts(params: {  "id": string; "fk": string; "data"?: PayEffectScript; }, options?: any) {
        return HistoryApiFp.historyPrototypeLinkAccountEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Add a related item by id for accounts.
     * @param id History id
     * @param fk Foreign key for accounts
     * @param data 
     */
    historyPrototypeLinkEffectScriptAccounts(params: {  "id": string; "fk": string; "data"?: PayEffectScript; }, options?: any) {
        return HistoryApiFp.historyPrototypeLinkEffectScriptAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id History id
     * @param data An object of model property name/value pairs
     */
    historyPrototypePatchAttributes(params: {  "id": string; "data"?: History; }, options?: any) {
        return HistoryApiFp.historyPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Remove the effectScripts relation to an item by id.
     * @param id History id
     * @param fk Foreign key for effectScripts
     */
    historyPrototypeUnlinkAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
        return HistoryApiFp.historyPrototypeUnlinkAccountEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Remove the accounts relation to an item by id.
     * @param id History id
     * @param fk Foreign key for accounts
     */
    historyPrototypeUnlinkEffectScriptAccounts(params: {  "id": string; "fk": string; }, options?: any) {
        return HistoryApiFp.historyPrototypeUnlinkEffectScriptAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id History id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    historyPrototypeUpdateByIdAccountAccessTokens(params: {  "id": string; "fk": string; "data"?: AccessToken; }, options?: any) {
        return HistoryApiFp.historyPrototypeUpdateByIdAccountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for effectScripts.
     * @param id History id
     * @param fk Foreign key for effectScripts
     * @param data 
     */
    historyPrototypeUpdateByIdAccountEffectScripts(params: {  "id": string; "fk": string; "data"?: EffectScript; }, options?: any) {
        return HistoryApiFp.historyPrototypeUpdateByIdAccountEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for histories.
     * @param id History id
     * @param fk Foreign key for histories
     * @param data 
     */
    historyPrototypeUpdateByIdAccountHistories(params: {  "id": string; "fk": string; "data"?: History; }, options?: any) {
        return HistoryApiFp.historyPrototypeUpdateByIdAccountHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for accounts.
     * @param id History id
     * @param fk Foreign key for accounts
     * @param data 
     */
    historyPrototypeUpdateByIdEffectScriptAccounts(params: {  "id": string; "fk": string; "data"?: Account; }, options?: any) {
        return HistoryApiFp.historyPrototypeUpdateByIdEffectScriptAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for histories.
     * @param id History id
     * @param fk Foreign key for histories
     * @param data 
     */
    historyPrototypeUpdateByIdEffectScriptHistories(params: {  "id": string; "fk": string; "data"?: History; }, options?: any) {
        return HistoryApiFp.historyPrototypeUpdateByIdEffectScriptHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    historyReplaceByIdPostHistoriesidReplace(params: {  "id": string; "data"?: History; }, options?: any) {
        return HistoryApiFp.historyReplaceByIdPostHistoriesidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    historyReplaceByIdPutHistoriesid(params: {  "id": string; "data"?: History; }, options?: any) {
        return HistoryApiFp.historyReplaceByIdPutHistoriesid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    historyReplaceOrCreatePostHistoriesReplaceOrCreate(params: {  "data"?: History; }, options?: any) {
        return HistoryApiFp.historyReplaceOrCreatePostHistoriesReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    historyReplaceOrCreatePutHistories(params: {  "data"?: History; }, options?: any) {
        return HistoryApiFp.historyReplaceOrCreatePutHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    historyUpdateAll(params: {  "where"?: string; "data"?: History; }, options?: any) {
        return HistoryApiFp.historyUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    historyUpsertWithWhere(params: {  "where"?: string; "data"?: History; }, options?: any) {
        return HistoryApiFp.historyUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * HistoryApi - factory interface
 */
export const HistoryApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        historyCount(params: {  "where"?: string; }, options?: any) {
            return HistoryApiFp.historyCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        historyCreate(params: {  "data"?: History; }, options?: any) {
            return HistoryApiFp.historyCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        historyCreateChangeStreamGetHistoriesChangeStream(params: {  "options"?: string; }, options?: any) {
            return HistoryApiFp.historyCreateChangeStreamGetHistoriesChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        historyCreateChangeStreamPostHistoriesChangeStream(params: {  "options"?: string; }, options?: any) {
            return HistoryApiFp.historyCreateChangeStreamPostHistoriesChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        historyDeleteById(params: {  "id": string; }, options?: any) {
            return HistoryApiFp.historyDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        historyExistsGetHistoriesidExists(params: {  "id": string; }, options?: any) {
            return HistoryApiFp.historyExistsGetHistoriesidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        historyExistsHeadHistoriesid(params: {  "id": string; }, options?: any) {
            return HistoryApiFp.historyExistsHeadHistoriesid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        historyFind(params: {  "filter"?: string; }, options?: any) {
            return HistoryApiFp.historyFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        historyFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return HistoryApiFp.historyFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        historyFindOne(params: {  "filter"?: string; }, options?: any) {
            return HistoryApiFp.historyFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        historyPatchOrCreate(params: {  "data"?: History; }, options?: any) {
            return HistoryApiFp.historyPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts accessTokens of Account.
         * @param id History id
         * @param where Criteria to match model instances
         */
        historyPrototypeCountAccountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any) {
            return HistoryApiFp.historyPrototypeCountAccountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts effectScripts of Account.
         * @param id History id
         * @param where Criteria to match model instances
         */
        historyPrototypeCountAccountEffectScripts(params: {  "id": string; "where"?: string; }, options?: any) {
            return HistoryApiFp.historyPrototypeCountAccountEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts histories of Account.
         * @param id History id
         * @param where Criteria to match model instances
         */
        historyPrototypeCountAccountHistories(params: {  "id": string; "where"?: string; }, options?: any) {
            return HistoryApiFp.historyPrototypeCountAccountHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts accounts of EffectScript.
         * @param id History id
         * @param where Criteria to match model instances
         */
        historyPrototypeCountEffectScriptAccounts(params: {  "id": string; "where"?: string; }, options?: any) {
            return HistoryApiFp.historyPrototypeCountEffectScriptAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts histories of EffectScript.
         * @param id History id
         * @param where Criteria to match model instances
         */
        historyPrototypeCountEffectScriptHistories(params: {  "id": string; "where"?: string; }, options?: any) {
            return HistoryApiFp.historyPrototypeCountEffectScriptHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in accessTokens of this model.
         * @param id History id
         * @param data 
         */
        historyPrototypeCreateAccountAccessTokens(params: {  "id": string; "data"?: AccessToken; }, options?: any) {
            return HistoryApiFp.historyPrototypeCreateAccountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in effectScripts of this model.
         * @param id History id
         * @param data 
         */
        historyPrototypeCreateAccountEffectScripts(params: {  "id": string; "data"?: EffectScript; }, options?: any) {
            return HistoryApiFp.historyPrototypeCreateAccountEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in histories of this model.
         * @param id History id
         * @param data 
         */
        historyPrototypeCreateAccountHistories(params: {  "id": string; "data"?: History; }, options?: any) {
            return HistoryApiFp.historyPrototypeCreateAccountHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in accounts of this model.
         * @param id History id
         * @param data 
         */
        historyPrototypeCreateEffectScriptAccounts(params: {  "id": string; "data"?: Account; }, options?: any) {
            return HistoryApiFp.historyPrototypeCreateEffectScriptAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in histories of this model.
         * @param id History id
         * @param data 
         */
        historyPrototypeCreateEffectScriptHistories(params: {  "id": string; "data"?: History; }, options?: any) {
            return HistoryApiFp.historyPrototypeCreateEffectScriptHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all accessTokens of this model.
         * @param id History id
         */
        historyPrototypeDeleteAccountAccessTokens(params: {  "id": string; }, options?: any) {
            return HistoryApiFp.historyPrototypeDeleteAccountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all effectScripts of this model.
         * @param id History id
         */
        historyPrototypeDeleteAccountEffectScripts(params: {  "id": string; }, options?: any) {
            return HistoryApiFp.historyPrototypeDeleteAccountEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all histories of this model.
         * @param id History id
         */
        historyPrototypeDeleteAccountHistories(params: {  "id": string; }, options?: any) {
            return HistoryApiFp.historyPrototypeDeleteAccountHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all accounts of this model.
         * @param id History id
         */
        historyPrototypeDeleteEffectScriptAccounts(params: {  "id": string; }, options?: any) {
            return HistoryApiFp.historyPrototypeDeleteEffectScriptAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all histories of this model.
         * @param id History id
         */
        historyPrototypeDeleteEffectScriptHistories(params: {  "id": string; }, options?: any) {
            return HistoryApiFp.historyPrototypeDeleteEffectScriptHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for accessTokens.
         * @param id History id
         * @param fk Foreign key for accessTokens
         */
        historyPrototypeDestroyByIdAccountAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
            return HistoryApiFp.historyPrototypeDestroyByIdAccountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for effectScripts.
         * @param id History id
         * @param fk Foreign key for effectScripts
         */
        historyPrototypeDestroyByIdAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
            return HistoryApiFp.historyPrototypeDestroyByIdAccountEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for histories.
         * @param id History id
         * @param fk Foreign key for histories
         */
        historyPrototypeDestroyByIdAccountHistories(params: {  "id": string; "fk": string; }, options?: any) {
            return HistoryApiFp.historyPrototypeDestroyByIdAccountHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for accounts.
         * @param id History id
         * @param fk Foreign key for accounts
         */
        historyPrototypeDestroyByIdEffectScriptAccounts(params: {  "id": string; "fk": string; }, options?: any) {
            return HistoryApiFp.historyPrototypeDestroyByIdEffectScriptAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for histories.
         * @param id History id
         * @param fk Foreign key for histories
         */
        historyPrototypeDestroyByIdEffectScriptHistories(params: {  "id": string; "fk": string; }, options?: any) {
            return HistoryApiFp.historyPrototypeDestroyByIdEffectScriptHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check the existence of effectScripts relation to an item by id.
         * @param id History id
         * @param fk Foreign key for effectScripts
         */
        historyPrototypeExistsAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
            return HistoryApiFp.historyPrototypeExistsAccountEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check the existence of accounts relation to an item by id.
         * @param id History id
         * @param fk Foreign key for accounts
         */
        historyPrototypeExistsEffectScriptAccounts(params: {  "id": string; "fk": string; }, options?: any) {
            return HistoryApiFp.historyPrototypeExistsEffectScriptAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for accessTokens.
         * @param id History id
         * @param fk Foreign key for accessTokens
         */
        historyPrototypeFindByIdAccountAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
            return HistoryApiFp.historyPrototypeFindByIdAccountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for effectScripts.
         * @param id History id
         * @param fk Foreign key for effectScripts
         */
        historyPrototypeFindByIdAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
            return HistoryApiFp.historyPrototypeFindByIdAccountEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for histories.
         * @param id History id
         * @param fk Foreign key for histories
         */
        historyPrototypeFindByIdAccountHistories(params: {  "id": string; "fk": string; }, options?: any) {
            return HistoryApiFp.historyPrototypeFindByIdAccountHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for accounts.
         * @param id History id
         * @param fk Foreign key for accounts
         */
        historyPrototypeFindByIdEffectScriptAccounts(params: {  "id": string; "fk": string; }, options?: any) {
            return HistoryApiFp.historyPrototypeFindByIdEffectScriptAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for histories.
         * @param id History id
         * @param fk Foreign key for histories
         */
        historyPrototypeFindByIdEffectScriptHistories(params: {  "id": string; "fk": string; }, options?: any) {
            return HistoryApiFp.historyPrototypeFindByIdEffectScriptHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation account.
         * @param id History id
         * @param refresh 
         */
        historyPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return HistoryApiFp.historyPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries accessTokens of Account.
         * @param id History id
         * @param filter 
         */
        historyPrototypeGetAccountAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any) {
            return HistoryApiFp.historyPrototypeGetAccountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries effectScripts of Account.
         * @param id History id
         * @param filter 
         */
        historyPrototypeGetAccountEffectScripts(params: {  "id": string; "filter"?: string; }, options?: any) {
            return HistoryApiFp.historyPrototypeGetAccountEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries histories of Account.
         * @param id History id
         * @param filter 
         */
        historyPrototypeGetAccountHistories(params: {  "id": string; "filter"?: string; }, options?: any) {
            return HistoryApiFp.historyPrototypeGetAccountHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation effectScript.
         * @param id History id
         * @param refresh 
         */
        historyPrototypeGetEffectScript(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return HistoryApiFp.historyPrototypeGetEffectScript(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries accounts of EffectScript.
         * @param id History id
         * @param filter 
         */
        historyPrototypeGetEffectScriptAccounts(params: {  "id": string; "filter"?: string; }, options?: any) {
            return HistoryApiFp.historyPrototypeGetEffectScriptAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries histories of EffectScript.
         * @param id History id
         * @param filter 
         */
        historyPrototypeGetEffectScriptHistories(params: {  "id": string; "filter"?: string; }, options?: any) {
            return HistoryApiFp.historyPrototypeGetEffectScriptHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add a related item by id for effectScripts.
         * @param id History id
         * @param fk Foreign key for effectScripts
         * @param data 
         */
        historyPrototypeLinkAccountEffectScripts(params: {  "id": string; "fk": string; "data"?: PayEffectScript; }, options?: any) {
            return HistoryApiFp.historyPrototypeLinkAccountEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add a related item by id for accounts.
         * @param id History id
         * @param fk Foreign key for accounts
         * @param data 
         */
        historyPrototypeLinkEffectScriptAccounts(params: {  "id": string; "fk": string; "data"?: PayEffectScript; }, options?: any) {
            return HistoryApiFp.historyPrototypeLinkEffectScriptAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id History id
         * @param data An object of model property name/value pairs
         */
        historyPrototypePatchAttributes(params: {  "id": string; "data"?: History; }, options?: any) {
            return HistoryApiFp.historyPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the effectScripts relation to an item by id.
         * @param id History id
         * @param fk Foreign key for effectScripts
         */
        historyPrototypeUnlinkAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
            return HistoryApiFp.historyPrototypeUnlinkAccountEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the accounts relation to an item by id.
         * @param id History id
         * @param fk Foreign key for accounts
         */
        historyPrototypeUnlinkEffectScriptAccounts(params: {  "id": string; "fk": string; }, options?: any) {
            return HistoryApiFp.historyPrototypeUnlinkEffectScriptAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for accessTokens.
         * @param id History id
         * @param fk Foreign key for accessTokens
         * @param data 
         */
        historyPrototypeUpdateByIdAccountAccessTokens(params: {  "id": string; "fk": string; "data"?: AccessToken; }, options?: any) {
            return HistoryApiFp.historyPrototypeUpdateByIdAccountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for effectScripts.
         * @param id History id
         * @param fk Foreign key for effectScripts
         * @param data 
         */
        historyPrototypeUpdateByIdAccountEffectScripts(params: {  "id": string; "fk": string; "data"?: EffectScript; }, options?: any) {
            return HistoryApiFp.historyPrototypeUpdateByIdAccountEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for histories.
         * @param id History id
         * @param fk Foreign key for histories
         * @param data 
         */
        historyPrototypeUpdateByIdAccountHistories(params: {  "id": string; "fk": string; "data"?: History; }, options?: any) {
            return HistoryApiFp.historyPrototypeUpdateByIdAccountHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for accounts.
         * @param id History id
         * @param fk Foreign key for accounts
         * @param data 
         */
        historyPrototypeUpdateByIdEffectScriptAccounts(params: {  "id": string; "fk": string; "data"?: Account; }, options?: any) {
            return HistoryApiFp.historyPrototypeUpdateByIdEffectScriptAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for histories.
         * @param id History id
         * @param fk Foreign key for histories
         * @param data 
         */
        historyPrototypeUpdateByIdEffectScriptHistories(params: {  "id": string; "fk": string; "data"?: History; }, options?: any) {
            return HistoryApiFp.historyPrototypeUpdateByIdEffectScriptHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        historyReplaceByIdPostHistoriesidReplace(params: {  "id": string; "data"?: History; }, options?: any) {
            return HistoryApiFp.historyReplaceByIdPostHistoriesidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        historyReplaceByIdPutHistoriesid(params: {  "id": string; "data"?: History; }, options?: any) {
            return HistoryApiFp.historyReplaceByIdPutHistoriesid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        historyReplaceOrCreatePostHistoriesReplaceOrCreate(params: {  "data"?: History; }, options?: any) {
            return HistoryApiFp.historyReplaceOrCreatePostHistoriesReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        historyReplaceOrCreatePutHistories(params: {  "data"?: History; }, options?: any) {
            return HistoryApiFp.historyReplaceOrCreatePutHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        historyUpdateAll(params: {  "where"?: string; "data"?: History; }, options?: any) {
            return HistoryApiFp.historyUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        historyUpsertWithWhere(params: {  "where"?: string; "data"?: History; }, options?: any) {
            return HistoryApiFp.historyUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * MessageApi - fetch parameter creator
 */
export const MessageApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    messageCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Messages/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    messageCreate(params: {  "data"?: Message; }, options?: any): FetchArgs {
        const baseUrl = `/Messages`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    messageCreateChangeStreamGetMessagesChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Messages/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    messageCreateChangeStreamPostMessagesChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Messages/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    messageDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messageDeleteById");
        }
        const baseUrl = `/Messages/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    messageExistsGetMessagesidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messageExistsGetMessagesidExists");
        }
        const baseUrl = `/Messages/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    messageExistsHeadMessagesid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messageExistsHeadMessagesid");
        }
        const baseUrl = `/Messages/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    messageFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Messages`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    messageFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messageFindById");
        }
        const baseUrl = `/Messages/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    messageFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Messages/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    messagePatchOrCreate(params: {  "data"?: Message; }, options?: any): FetchArgs {
        const baseUrl = `/Messages`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts accessTokens of Account.
     * @param id Message id
     * @param where Criteria to match model instances
     */
    messagePrototypeCountAccountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeCountAccountAccessTokens");
        }
        const baseUrl = `/Messages/{id}/account/accessTokens/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts effectScripts of Account.
     * @param id Message id
     * @param where Criteria to match model instances
     */
    messagePrototypeCountAccountEffectScripts(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeCountAccountEffectScripts");
        }
        const baseUrl = `/Messages/{id}/account/effectScripts/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts histories of Account.
     * @param id Message id
     * @param where Criteria to match model instances
     */
    messagePrototypeCountAccountHistories(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeCountAccountHistories");
        }
        const baseUrl = `/Messages/{id}/account/histories/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts messages of Account.
     * @param id Message id
     * @param where Criteria to match model instances
     */
    messagePrototypeCountAccountMessages(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeCountAccountMessages");
        }
        const baseUrl = `/Messages/{id}/account/messages/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Message id
     * @param data 
     */
    messagePrototypeCreateAccountAccessTokens(params: {  "id": string; "data"?: AccessToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeCreateAccountAccessTokens");
        }
        const baseUrl = `/Messages/{id}/account/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in effectScripts of this model.
     * @param id Message id
     * @param data 
     */
    messagePrototypeCreateAccountEffectScripts(params: {  "id": string; "data"?: EffectScript; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeCreateAccountEffectScripts");
        }
        const baseUrl = `/Messages/{id}/account/effectScripts`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in histories of this model.
     * @param id Message id
     * @param data 
     */
    messagePrototypeCreateAccountHistories(params: {  "id": string; "data"?: History; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeCreateAccountHistories");
        }
        const baseUrl = `/Messages/{id}/account/histories`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in messages of this model.
     * @param id Message id
     * @param data 
     */
    messagePrototypeCreateAccountMessages(params: {  "id": string; "data"?: Message; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeCreateAccountMessages");
        }
        const baseUrl = `/Messages/{id}/account/messages`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id Message id
     */
    messagePrototypeDeleteAccountAccessTokens(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeDeleteAccountAccessTokens");
        }
        const baseUrl = `/Messages/{id}/account/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all effectScripts of this model.
     * @param id Message id
     */
    messagePrototypeDeleteAccountEffectScripts(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeDeleteAccountEffectScripts");
        }
        const baseUrl = `/Messages/{id}/account/effectScripts`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all histories of this model.
     * @param id Message id
     */
    messagePrototypeDeleteAccountHistories(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeDeleteAccountHistories");
        }
        const baseUrl = `/Messages/{id}/account/histories`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all messages of this model.
     * @param id Message id
     */
    messagePrototypeDeleteAccountMessages(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeDeleteAccountMessages");
        }
        const baseUrl = `/Messages/{id}/account/messages`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id Message id
     * @param fk Foreign key for accessTokens
     */
    messagePrototypeDestroyByIdAccountAccessTokens(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeDestroyByIdAccountAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling messagePrototypeDestroyByIdAccountAccessTokens");
        }
        const baseUrl = `/Messages/{id}/account/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for effectScripts.
     * @param id Message id
     * @param fk Foreign key for effectScripts
     */
    messagePrototypeDestroyByIdAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeDestroyByIdAccountEffectScripts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling messagePrototypeDestroyByIdAccountEffectScripts");
        }
        const baseUrl = `/Messages/{id}/account/effectScripts/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for histories.
     * @param id Message id
     * @param fk Foreign key for histories
     */
    messagePrototypeDestroyByIdAccountHistories(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeDestroyByIdAccountHistories");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling messagePrototypeDestroyByIdAccountHistories");
        }
        const baseUrl = `/Messages/{id}/account/histories/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for messages.
     * @param id Message id
     * @param fk Foreign key for messages
     */
    messagePrototypeDestroyByIdAccountMessages(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeDestroyByIdAccountMessages");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling messagePrototypeDestroyByIdAccountMessages");
        }
        const baseUrl = `/Messages/{id}/account/messages/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check the existence of effectScripts relation to an item by id.
     * @param id Message id
     * @param fk Foreign key for effectScripts
     */
    messagePrototypeExistsAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeExistsAccountEffectScripts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling messagePrototypeExistsAccountEffectScripts");
        }
        const baseUrl = `/Messages/{id}/account/effectScripts/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id Message id
     * @param fk Foreign key for accessTokens
     */
    messagePrototypeFindByIdAccountAccessTokens(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeFindByIdAccountAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling messagePrototypeFindByIdAccountAccessTokens");
        }
        const baseUrl = `/Messages/{id}/account/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for effectScripts.
     * @param id Message id
     * @param fk Foreign key for effectScripts
     */
    messagePrototypeFindByIdAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeFindByIdAccountEffectScripts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling messagePrototypeFindByIdAccountEffectScripts");
        }
        const baseUrl = `/Messages/{id}/account/effectScripts/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for histories.
     * @param id Message id
     * @param fk Foreign key for histories
     */
    messagePrototypeFindByIdAccountHistories(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeFindByIdAccountHistories");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling messagePrototypeFindByIdAccountHistories");
        }
        const baseUrl = `/Messages/{id}/account/histories/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for messages.
     * @param id Message id
     * @param fk Foreign key for messages
     */
    messagePrototypeFindByIdAccountMessages(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeFindByIdAccountMessages");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling messagePrototypeFindByIdAccountMessages");
        }
        const baseUrl = `/Messages/{id}/account/messages/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Message id
     * @param refresh 
     */
    messagePrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeGetAccount");
        }
        const baseUrl = `/Messages/{id}/account`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries accessTokens of Account.
     * @param id Message id
     * @param filter 
     */
    messagePrototypeGetAccountAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeGetAccountAccessTokens");
        }
        const baseUrl = `/Messages/{id}/account/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries effectScripts of Account.
     * @param id Message id
     * @param filter 
     */
    messagePrototypeGetAccountEffectScripts(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeGetAccountEffectScripts");
        }
        const baseUrl = `/Messages/{id}/account/effectScripts`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries histories of Account.
     * @param id Message id
     * @param filter 
     */
    messagePrototypeGetAccountHistories(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeGetAccountHistories");
        }
        const baseUrl = `/Messages/{id}/account/histories`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries messages of Account.
     * @param id Message id
     * @param filter 
     */
    messagePrototypeGetAccountMessages(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeGetAccountMessages");
        }
        const baseUrl = `/Messages/{id}/account/messages`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Add a related item by id for effectScripts.
     * @param id Message id
     * @param fk Foreign key for effectScripts
     * @param data 
     */
    messagePrototypeLinkAccountEffectScripts(params: {  "id": string; "fk": string; "data"?: PayEffectScript; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeLinkAccountEffectScripts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling messagePrototypeLinkAccountEffectScripts");
        }
        const baseUrl = `/Messages/{id}/account/effectScripts/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Message id
     * @param data An object of model property name/value pairs
     */
    messagePrototypePatchAttributes(params: {  "id": string; "data"?: Message; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypePatchAttributes");
        }
        const baseUrl = `/Messages/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Remove the effectScripts relation to an item by id.
     * @param id Message id
     * @param fk Foreign key for effectScripts
     */
    messagePrototypeUnlinkAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeUnlinkAccountEffectScripts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling messagePrototypeUnlinkAccountEffectScripts");
        }
        const baseUrl = `/Messages/{id}/account/effectScripts/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id Message id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    messagePrototypeUpdateByIdAccountAccessTokens(params: {  "id": string; "fk": string; "data"?: AccessToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeUpdateByIdAccountAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling messagePrototypeUpdateByIdAccountAccessTokens");
        }
        const baseUrl = `/Messages/{id}/account/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for effectScripts.
     * @param id Message id
     * @param fk Foreign key for effectScripts
     * @param data 
     */
    messagePrototypeUpdateByIdAccountEffectScripts(params: {  "id": string; "fk": string; "data"?: EffectScript; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeUpdateByIdAccountEffectScripts");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling messagePrototypeUpdateByIdAccountEffectScripts");
        }
        const baseUrl = `/Messages/{id}/account/effectScripts/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for histories.
     * @param id Message id
     * @param fk Foreign key for histories
     * @param data 
     */
    messagePrototypeUpdateByIdAccountHistories(params: {  "id": string; "fk": string; "data"?: History; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeUpdateByIdAccountHistories");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling messagePrototypeUpdateByIdAccountHistories");
        }
        const baseUrl = `/Messages/{id}/account/histories/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for messages.
     * @param id Message id
     * @param fk Foreign key for messages
     * @param data 
     */
    messagePrototypeUpdateByIdAccountMessages(params: {  "id": string; "fk": string; "data"?: Message; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messagePrototypeUpdateByIdAccountMessages");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling messagePrototypeUpdateByIdAccountMessages");
        }
        const baseUrl = `/Messages/{id}/account/messages/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    messageReplaceByIdPostMessagesidReplace(params: {  "id": string; "data"?: Message; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messageReplaceByIdPostMessagesidReplace");
        }
        const baseUrl = `/Messages/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    messageReplaceByIdPutMessagesid(params: {  "id": string; "data"?: Message; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling messageReplaceByIdPutMessagesid");
        }
        const baseUrl = `/Messages/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    messageReplaceOrCreatePostMessagesReplaceOrCreate(params: {  "data"?: Message; }, options?: any): FetchArgs {
        const baseUrl = `/Messages/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    messageReplaceOrCreatePutMessages(params: {  "data"?: Message; }, options?: any): FetchArgs {
        const baseUrl = `/Messages`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    messageUpdateAll(params: {  "where"?: string; "data"?: Message; }, options?: any): FetchArgs {
        const baseUrl = `/Messages/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    messageUpsertWithWhere(params: {  "where"?: string; "data"?: Message; }, options?: any): FetchArgs {
        const baseUrl = `/Messages/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * MessageApi - functional programming interface
 */
export const MessageApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    messageCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = MessageApiFetchParamCreator.messageCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    messageCreate(params: { "data"?: Message;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Message> {
        const fetchArgs = MessageApiFetchParamCreator.messageCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    messageCreateChangeStreamGetMessagesChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessageApiFetchParamCreator.messageCreateChangeStreamGetMessagesChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    messageCreateChangeStreamPostMessagesChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessageApiFetchParamCreator.messageCreateChangeStreamPostMessagesChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    messageDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessageApiFetchParamCreator.messageDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    messageExistsGetMessagesidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = MessageApiFetchParamCreator.messageExistsGetMessagesidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    messageExistsHeadMessagesid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = MessageApiFetchParamCreator.messageExistsHeadMessagesid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    messageFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Message>> {
        const fetchArgs = MessageApiFetchParamCreator.messageFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    messageFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Message> {
        const fetchArgs = MessageApiFetchParamCreator.messageFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    messageFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Message> {
        const fetchArgs = MessageApiFetchParamCreator.messageFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    messagePatchOrCreate(params: { "data"?: Message;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Message> {
        const fetchArgs = MessageApiFetchParamCreator.messagePatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts accessTokens of Account.
     * @param id Message id
     * @param where Criteria to match model instances
     */
    messagePrototypeCountAccountAccessTokens(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeCountAccountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts effectScripts of Account.
     * @param id Message id
     * @param where Criteria to match model instances
     */
    messagePrototypeCountAccountEffectScripts(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeCountAccountEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts histories of Account.
     * @param id Message id
     * @param where Criteria to match model instances
     */
    messagePrototypeCountAccountHistories(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeCountAccountHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts messages of Account.
     * @param id Message id
     * @param where Criteria to match model instances
     */
    messagePrototypeCountAccountMessages(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeCountAccountMessages(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Message id
     * @param data 
     */
    messagePrototypeCreateAccountAccessTokens(params: { "id": string; "data"?: AccessToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeCreateAccountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in effectScripts of this model.
     * @param id Message id
     * @param data 
     */
    messagePrototypeCreateAccountEffectScripts(params: { "id": string; "data"?: EffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeCreateAccountEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in histories of this model.
     * @param id Message id
     * @param data 
     */
    messagePrototypeCreateAccountHistories(params: { "id": string; "data"?: History;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeCreateAccountHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in messages of this model.
     * @param id Message id
     * @param data 
     */
    messagePrototypeCreateAccountMessages(params: { "id": string; "data"?: Message;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Message> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeCreateAccountMessages(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id Message id
     */
    messagePrototypeDeleteAccountAccessTokens(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeDeleteAccountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all effectScripts of this model.
     * @param id Message id
     */
    messagePrototypeDeleteAccountEffectScripts(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeDeleteAccountEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all histories of this model.
     * @param id Message id
     */
    messagePrototypeDeleteAccountHistories(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeDeleteAccountHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all messages of this model.
     * @param id Message id
     */
    messagePrototypeDeleteAccountMessages(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeDeleteAccountMessages(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id Message id
     * @param fk Foreign key for accessTokens
     */
    messagePrototypeDestroyByIdAccountAccessTokens(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeDestroyByIdAccountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for effectScripts.
     * @param id Message id
     * @param fk Foreign key for effectScripts
     */
    messagePrototypeDestroyByIdAccountEffectScripts(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeDestroyByIdAccountEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for histories.
     * @param id Message id
     * @param fk Foreign key for histories
     */
    messagePrototypeDestroyByIdAccountHistories(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeDestroyByIdAccountHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for messages.
     * @param id Message id
     * @param fk Foreign key for messages
     */
    messagePrototypeDestroyByIdAccountMessages(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeDestroyByIdAccountMessages(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check the existence of effectScripts relation to an item by id.
     * @param id Message id
     * @param fk Foreign key for effectScripts
     */
    messagePrototypeExistsAccountEffectScripts(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeExistsAccountEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id Message id
     * @param fk Foreign key for accessTokens
     */
    messagePrototypeFindByIdAccountAccessTokens(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeFindByIdAccountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for effectScripts.
     * @param id Message id
     * @param fk Foreign key for effectScripts
     */
    messagePrototypeFindByIdAccountEffectScripts(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeFindByIdAccountEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for histories.
     * @param id Message id
     * @param fk Foreign key for histories
     */
    messagePrototypeFindByIdAccountHistories(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeFindByIdAccountHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for messages.
     * @param id Message id
     * @param fk Foreign key for messages
     */
    messagePrototypeFindByIdAccountMessages(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Message> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeFindByIdAccountMessages(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Message id
     * @param refresh 
     */
    messagePrototypeGetAccount(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeGetAccount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries accessTokens of Account.
     * @param id Message id
     * @param filter 
     */
    messagePrototypeGetAccountAccessTokens(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccessToken>> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeGetAccountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries effectScripts of Account.
     * @param id Message id
     * @param filter 
     */
    messagePrototypeGetAccountEffectScripts(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EffectScript>> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeGetAccountEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries histories of Account.
     * @param id Message id
     * @param filter 
     */
    messagePrototypeGetAccountHistories(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<History>> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeGetAccountHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries messages of Account.
     * @param id Message id
     * @param filter 
     */
    messagePrototypeGetAccountMessages(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Message>> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeGetAccountMessages(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Add a related item by id for effectScripts.
     * @param id Message id
     * @param fk Foreign key for effectScripts
     * @param data 
     */
    messagePrototypeLinkAccountEffectScripts(params: { "id": string; "fk": string; "data"?: PayEffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayEffectScript> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeLinkAccountEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Message id
     * @param data An object of model property name/value pairs
     */
    messagePrototypePatchAttributes(params: { "id": string; "data"?: Message;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Message> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Remove the effectScripts relation to an item by id.
     * @param id Message id
     * @param fk Foreign key for effectScripts
     */
    messagePrototypeUnlinkAccountEffectScripts(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeUnlinkAccountEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id Message id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    messagePrototypeUpdateByIdAccountAccessTokens(params: { "id": string; "fk": string; "data"?: AccessToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeUpdateByIdAccountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for effectScripts.
     * @param id Message id
     * @param fk Foreign key for effectScripts
     * @param data 
     */
    messagePrototypeUpdateByIdAccountEffectScripts(params: { "id": string; "fk": string; "data"?: EffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeUpdateByIdAccountEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for histories.
     * @param id Message id
     * @param fk Foreign key for histories
     * @param data 
     */
    messagePrototypeUpdateByIdAccountHistories(params: { "id": string; "fk": string; "data"?: History;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<History> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeUpdateByIdAccountHistories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for messages.
     * @param id Message id
     * @param fk Foreign key for messages
     * @param data 
     */
    messagePrototypeUpdateByIdAccountMessages(params: { "id": string; "fk": string; "data"?: Message;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Message> {
        const fetchArgs = MessageApiFetchParamCreator.messagePrototypeUpdateByIdAccountMessages(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    messageReplaceByIdPostMessagesidReplace(params: { "id": string; "data"?: Message;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Message> {
        const fetchArgs = MessageApiFetchParamCreator.messageReplaceByIdPostMessagesidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    messageReplaceByIdPutMessagesid(params: { "id": string; "data"?: Message;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Message> {
        const fetchArgs = MessageApiFetchParamCreator.messageReplaceByIdPutMessagesid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    messageReplaceOrCreatePostMessagesReplaceOrCreate(params: { "data"?: Message;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Message> {
        const fetchArgs = MessageApiFetchParamCreator.messageReplaceOrCreatePostMessagesReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    messageReplaceOrCreatePutMessages(params: { "data"?: Message;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Message> {
        const fetchArgs = MessageApiFetchParamCreator.messageReplaceOrCreatePutMessages(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    messageUpdateAll(params: { "where"?: string; "data"?: Message;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = MessageApiFetchParamCreator.messageUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    messageUpsertWithWhere(params: { "where"?: string; "data"?: Message;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Message> {
        const fetchArgs = MessageApiFetchParamCreator.messageUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * MessageApi - object-oriented interface
 */
export class MessageApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    messageCount(params: {  "where"?: string; }, options?: any) {
        return MessageApiFp.messageCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    messageCreate(params: {  "data"?: Message; }, options?: any) {
        return MessageApiFp.messageCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    messageCreateChangeStreamGetMessagesChangeStream(params: {  "options"?: string; }, options?: any) {
        return MessageApiFp.messageCreateChangeStreamGetMessagesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    messageCreateChangeStreamPostMessagesChangeStream(params: {  "options"?: string; }, options?: any) {
        return MessageApiFp.messageCreateChangeStreamPostMessagesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    messageDeleteById(params: {  "id": string; }, options?: any) {
        return MessageApiFp.messageDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    messageExistsGetMessagesidExists(params: {  "id": string; }, options?: any) {
        return MessageApiFp.messageExistsGetMessagesidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    messageExistsHeadMessagesid(params: {  "id": string; }, options?: any) {
        return MessageApiFp.messageExistsHeadMessagesid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    messageFind(params: {  "filter"?: string; }, options?: any) {
        return MessageApiFp.messageFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    messageFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return MessageApiFp.messageFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    messageFindOne(params: {  "filter"?: string; }, options?: any) {
        return MessageApiFp.messageFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    messagePatchOrCreate(params: {  "data"?: Message; }, options?: any) {
        return MessageApiFp.messagePatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts accessTokens of Account.
     * @param id Message id
     * @param where Criteria to match model instances
     */
    messagePrototypeCountAccountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any) {
        return MessageApiFp.messagePrototypeCountAccountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts effectScripts of Account.
     * @param id Message id
     * @param where Criteria to match model instances
     */
    messagePrototypeCountAccountEffectScripts(params: {  "id": string; "where"?: string; }, options?: any) {
        return MessageApiFp.messagePrototypeCountAccountEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts histories of Account.
     * @param id Message id
     * @param where Criteria to match model instances
     */
    messagePrototypeCountAccountHistories(params: {  "id": string; "where"?: string; }, options?: any) {
        return MessageApiFp.messagePrototypeCountAccountHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts messages of Account.
     * @param id Message id
     * @param where Criteria to match model instances
     */
    messagePrototypeCountAccountMessages(params: {  "id": string; "where"?: string; }, options?: any) {
        return MessageApiFp.messagePrototypeCountAccountMessages(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Message id
     * @param data 
     */
    messagePrototypeCreateAccountAccessTokens(params: {  "id": string; "data"?: AccessToken; }, options?: any) {
        return MessageApiFp.messagePrototypeCreateAccountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in effectScripts of this model.
     * @param id Message id
     * @param data 
     */
    messagePrototypeCreateAccountEffectScripts(params: {  "id": string; "data"?: EffectScript; }, options?: any) {
        return MessageApiFp.messagePrototypeCreateAccountEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in histories of this model.
     * @param id Message id
     * @param data 
     */
    messagePrototypeCreateAccountHistories(params: {  "id": string; "data"?: History; }, options?: any) {
        return MessageApiFp.messagePrototypeCreateAccountHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in messages of this model.
     * @param id Message id
     * @param data 
     */
    messagePrototypeCreateAccountMessages(params: {  "id": string; "data"?: Message; }, options?: any) {
        return MessageApiFp.messagePrototypeCreateAccountMessages(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id Message id
     */
    messagePrototypeDeleteAccountAccessTokens(params: {  "id": string; }, options?: any) {
        return MessageApiFp.messagePrototypeDeleteAccountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all effectScripts of this model.
     * @param id Message id
     */
    messagePrototypeDeleteAccountEffectScripts(params: {  "id": string; }, options?: any) {
        return MessageApiFp.messagePrototypeDeleteAccountEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all histories of this model.
     * @param id Message id
     */
    messagePrototypeDeleteAccountHistories(params: {  "id": string; }, options?: any) {
        return MessageApiFp.messagePrototypeDeleteAccountHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all messages of this model.
     * @param id Message id
     */
    messagePrototypeDeleteAccountMessages(params: {  "id": string; }, options?: any) {
        return MessageApiFp.messagePrototypeDeleteAccountMessages(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id Message id
     * @param fk Foreign key for accessTokens
     */
    messagePrototypeDestroyByIdAccountAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
        return MessageApiFp.messagePrototypeDestroyByIdAccountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for effectScripts.
     * @param id Message id
     * @param fk Foreign key for effectScripts
     */
    messagePrototypeDestroyByIdAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
        return MessageApiFp.messagePrototypeDestroyByIdAccountEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for histories.
     * @param id Message id
     * @param fk Foreign key for histories
     */
    messagePrototypeDestroyByIdAccountHistories(params: {  "id": string; "fk": string; }, options?: any) {
        return MessageApiFp.messagePrototypeDestroyByIdAccountHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for messages.
     * @param id Message id
     * @param fk Foreign key for messages
     */
    messagePrototypeDestroyByIdAccountMessages(params: {  "id": string; "fk": string; }, options?: any) {
        return MessageApiFp.messagePrototypeDestroyByIdAccountMessages(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check the existence of effectScripts relation to an item by id.
     * @param id Message id
     * @param fk Foreign key for effectScripts
     */
    messagePrototypeExistsAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
        return MessageApiFp.messagePrototypeExistsAccountEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id Message id
     * @param fk Foreign key for accessTokens
     */
    messagePrototypeFindByIdAccountAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
        return MessageApiFp.messagePrototypeFindByIdAccountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for effectScripts.
     * @param id Message id
     * @param fk Foreign key for effectScripts
     */
    messagePrototypeFindByIdAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
        return MessageApiFp.messagePrototypeFindByIdAccountEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for histories.
     * @param id Message id
     * @param fk Foreign key for histories
     */
    messagePrototypeFindByIdAccountHistories(params: {  "id": string; "fk": string; }, options?: any) {
        return MessageApiFp.messagePrototypeFindByIdAccountHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for messages.
     * @param id Message id
     * @param fk Foreign key for messages
     */
    messagePrototypeFindByIdAccountMessages(params: {  "id": string; "fk": string; }, options?: any) {
        return MessageApiFp.messagePrototypeFindByIdAccountMessages(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Message id
     * @param refresh 
     */
    messagePrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return MessageApiFp.messagePrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries accessTokens of Account.
     * @param id Message id
     * @param filter 
     */
    messagePrototypeGetAccountAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any) {
        return MessageApiFp.messagePrototypeGetAccountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries effectScripts of Account.
     * @param id Message id
     * @param filter 
     */
    messagePrototypeGetAccountEffectScripts(params: {  "id": string; "filter"?: string; }, options?: any) {
        return MessageApiFp.messagePrototypeGetAccountEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries histories of Account.
     * @param id Message id
     * @param filter 
     */
    messagePrototypeGetAccountHistories(params: {  "id": string; "filter"?: string; }, options?: any) {
        return MessageApiFp.messagePrototypeGetAccountHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries messages of Account.
     * @param id Message id
     * @param filter 
     */
    messagePrototypeGetAccountMessages(params: {  "id": string; "filter"?: string; }, options?: any) {
        return MessageApiFp.messagePrototypeGetAccountMessages(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Add a related item by id for effectScripts.
     * @param id Message id
     * @param fk Foreign key for effectScripts
     * @param data 
     */
    messagePrototypeLinkAccountEffectScripts(params: {  "id": string; "fk": string; "data"?: PayEffectScript; }, options?: any) {
        return MessageApiFp.messagePrototypeLinkAccountEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Message id
     * @param data An object of model property name/value pairs
     */
    messagePrototypePatchAttributes(params: {  "id": string; "data"?: Message; }, options?: any) {
        return MessageApiFp.messagePrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Remove the effectScripts relation to an item by id.
     * @param id Message id
     * @param fk Foreign key for effectScripts
     */
    messagePrototypeUnlinkAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
        return MessageApiFp.messagePrototypeUnlinkAccountEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id Message id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    messagePrototypeUpdateByIdAccountAccessTokens(params: {  "id": string; "fk": string; "data"?: AccessToken; }, options?: any) {
        return MessageApiFp.messagePrototypeUpdateByIdAccountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for effectScripts.
     * @param id Message id
     * @param fk Foreign key for effectScripts
     * @param data 
     */
    messagePrototypeUpdateByIdAccountEffectScripts(params: {  "id": string; "fk": string; "data"?: EffectScript; }, options?: any) {
        return MessageApiFp.messagePrototypeUpdateByIdAccountEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for histories.
     * @param id Message id
     * @param fk Foreign key for histories
     * @param data 
     */
    messagePrototypeUpdateByIdAccountHistories(params: {  "id": string; "fk": string; "data"?: History; }, options?: any) {
        return MessageApiFp.messagePrototypeUpdateByIdAccountHistories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for messages.
     * @param id Message id
     * @param fk Foreign key for messages
     * @param data 
     */
    messagePrototypeUpdateByIdAccountMessages(params: {  "id": string; "fk": string; "data"?: Message; }, options?: any) {
        return MessageApiFp.messagePrototypeUpdateByIdAccountMessages(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    messageReplaceByIdPostMessagesidReplace(params: {  "id": string; "data"?: Message; }, options?: any) {
        return MessageApiFp.messageReplaceByIdPostMessagesidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    messageReplaceByIdPutMessagesid(params: {  "id": string; "data"?: Message; }, options?: any) {
        return MessageApiFp.messageReplaceByIdPutMessagesid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    messageReplaceOrCreatePostMessagesReplaceOrCreate(params: {  "data"?: Message; }, options?: any) {
        return MessageApiFp.messageReplaceOrCreatePostMessagesReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    messageReplaceOrCreatePutMessages(params: {  "data"?: Message; }, options?: any) {
        return MessageApiFp.messageReplaceOrCreatePutMessages(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    messageUpdateAll(params: {  "where"?: string; "data"?: Message; }, options?: any) {
        return MessageApiFp.messageUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    messageUpsertWithWhere(params: {  "where"?: string; "data"?: Message; }, options?: any) {
        return MessageApiFp.messageUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * MessageApi - factory interface
 */
export const MessageApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        messageCount(params: {  "where"?: string; }, options?: any) {
            return MessageApiFp.messageCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        messageCreate(params: {  "data"?: Message; }, options?: any) {
            return MessageApiFp.messageCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        messageCreateChangeStreamGetMessagesChangeStream(params: {  "options"?: string; }, options?: any) {
            return MessageApiFp.messageCreateChangeStreamGetMessagesChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        messageCreateChangeStreamPostMessagesChangeStream(params: {  "options"?: string; }, options?: any) {
            return MessageApiFp.messageCreateChangeStreamPostMessagesChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        messageDeleteById(params: {  "id": string; }, options?: any) {
            return MessageApiFp.messageDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        messageExistsGetMessagesidExists(params: {  "id": string; }, options?: any) {
            return MessageApiFp.messageExistsGetMessagesidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        messageExistsHeadMessagesid(params: {  "id": string; }, options?: any) {
            return MessageApiFp.messageExistsHeadMessagesid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        messageFind(params: {  "filter"?: string; }, options?: any) {
            return MessageApiFp.messageFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        messageFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return MessageApiFp.messageFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        messageFindOne(params: {  "filter"?: string; }, options?: any) {
            return MessageApiFp.messageFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        messagePatchOrCreate(params: {  "data"?: Message; }, options?: any) {
            return MessageApiFp.messagePatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts accessTokens of Account.
         * @param id Message id
         * @param where Criteria to match model instances
         */
        messagePrototypeCountAccountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any) {
            return MessageApiFp.messagePrototypeCountAccountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts effectScripts of Account.
         * @param id Message id
         * @param where Criteria to match model instances
         */
        messagePrototypeCountAccountEffectScripts(params: {  "id": string; "where"?: string; }, options?: any) {
            return MessageApiFp.messagePrototypeCountAccountEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts histories of Account.
         * @param id Message id
         * @param where Criteria to match model instances
         */
        messagePrototypeCountAccountHistories(params: {  "id": string; "where"?: string; }, options?: any) {
            return MessageApiFp.messagePrototypeCountAccountHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts messages of Account.
         * @param id Message id
         * @param where Criteria to match model instances
         */
        messagePrototypeCountAccountMessages(params: {  "id": string; "where"?: string; }, options?: any) {
            return MessageApiFp.messagePrototypeCountAccountMessages(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in accessTokens of this model.
         * @param id Message id
         * @param data 
         */
        messagePrototypeCreateAccountAccessTokens(params: {  "id": string; "data"?: AccessToken; }, options?: any) {
            return MessageApiFp.messagePrototypeCreateAccountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in effectScripts of this model.
         * @param id Message id
         * @param data 
         */
        messagePrototypeCreateAccountEffectScripts(params: {  "id": string; "data"?: EffectScript; }, options?: any) {
            return MessageApiFp.messagePrototypeCreateAccountEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in histories of this model.
         * @param id Message id
         * @param data 
         */
        messagePrototypeCreateAccountHistories(params: {  "id": string; "data"?: History; }, options?: any) {
            return MessageApiFp.messagePrototypeCreateAccountHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in messages of this model.
         * @param id Message id
         * @param data 
         */
        messagePrototypeCreateAccountMessages(params: {  "id": string; "data"?: Message; }, options?: any) {
            return MessageApiFp.messagePrototypeCreateAccountMessages(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all accessTokens of this model.
         * @param id Message id
         */
        messagePrototypeDeleteAccountAccessTokens(params: {  "id": string; }, options?: any) {
            return MessageApiFp.messagePrototypeDeleteAccountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all effectScripts of this model.
         * @param id Message id
         */
        messagePrototypeDeleteAccountEffectScripts(params: {  "id": string; }, options?: any) {
            return MessageApiFp.messagePrototypeDeleteAccountEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all histories of this model.
         * @param id Message id
         */
        messagePrototypeDeleteAccountHistories(params: {  "id": string; }, options?: any) {
            return MessageApiFp.messagePrototypeDeleteAccountHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all messages of this model.
         * @param id Message id
         */
        messagePrototypeDeleteAccountMessages(params: {  "id": string; }, options?: any) {
            return MessageApiFp.messagePrototypeDeleteAccountMessages(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for accessTokens.
         * @param id Message id
         * @param fk Foreign key for accessTokens
         */
        messagePrototypeDestroyByIdAccountAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
            return MessageApiFp.messagePrototypeDestroyByIdAccountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for effectScripts.
         * @param id Message id
         * @param fk Foreign key for effectScripts
         */
        messagePrototypeDestroyByIdAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
            return MessageApiFp.messagePrototypeDestroyByIdAccountEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for histories.
         * @param id Message id
         * @param fk Foreign key for histories
         */
        messagePrototypeDestroyByIdAccountHistories(params: {  "id": string; "fk": string; }, options?: any) {
            return MessageApiFp.messagePrototypeDestroyByIdAccountHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for messages.
         * @param id Message id
         * @param fk Foreign key for messages
         */
        messagePrototypeDestroyByIdAccountMessages(params: {  "id": string; "fk": string; }, options?: any) {
            return MessageApiFp.messagePrototypeDestroyByIdAccountMessages(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check the existence of effectScripts relation to an item by id.
         * @param id Message id
         * @param fk Foreign key for effectScripts
         */
        messagePrototypeExistsAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
            return MessageApiFp.messagePrototypeExistsAccountEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for accessTokens.
         * @param id Message id
         * @param fk Foreign key for accessTokens
         */
        messagePrototypeFindByIdAccountAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
            return MessageApiFp.messagePrototypeFindByIdAccountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for effectScripts.
         * @param id Message id
         * @param fk Foreign key for effectScripts
         */
        messagePrototypeFindByIdAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
            return MessageApiFp.messagePrototypeFindByIdAccountEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for histories.
         * @param id Message id
         * @param fk Foreign key for histories
         */
        messagePrototypeFindByIdAccountHistories(params: {  "id": string; "fk": string; }, options?: any) {
            return MessageApiFp.messagePrototypeFindByIdAccountHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for messages.
         * @param id Message id
         * @param fk Foreign key for messages
         */
        messagePrototypeFindByIdAccountMessages(params: {  "id": string; "fk": string; }, options?: any) {
            return MessageApiFp.messagePrototypeFindByIdAccountMessages(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation account.
         * @param id Message id
         * @param refresh 
         */
        messagePrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return MessageApiFp.messagePrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries accessTokens of Account.
         * @param id Message id
         * @param filter 
         */
        messagePrototypeGetAccountAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any) {
            return MessageApiFp.messagePrototypeGetAccountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries effectScripts of Account.
         * @param id Message id
         * @param filter 
         */
        messagePrototypeGetAccountEffectScripts(params: {  "id": string; "filter"?: string; }, options?: any) {
            return MessageApiFp.messagePrototypeGetAccountEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries histories of Account.
         * @param id Message id
         * @param filter 
         */
        messagePrototypeGetAccountHistories(params: {  "id": string; "filter"?: string; }, options?: any) {
            return MessageApiFp.messagePrototypeGetAccountHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries messages of Account.
         * @param id Message id
         * @param filter 
         */
        messagePrototypeGetAccountMessages(params: {  "id": string; "filter"?: string; }, options?: any) {
            return MessageApiFp.messagePrototypeGetAccountMessages(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add a related item by id for effectScripts.
         * @param id Message id
         * @param fk Foreign key for effectScripts
         * @param data 
         */
        messagePrototypeLinkAccountEffectScripts(params: {  "id": string; "fk": string; "data"?: PayEffectScript; }, options?: any) {
            return MessageApiFp.messagePrototypeLinkAccountEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Message id
         * @param data An object of model property name/value pairs
         */
        messagePrototypePatchAttributes(params: {  "id": string; "data"?: Message; }, options?: any) {
            return MessageApiFp.messagePrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the effectScripts relation to an item by id.
         * @param id Message id
         * @param fk Foreign key for effectScripts
         */
        messagePrototypeUnlinkAccountEffectScripts(params: {  "id": string; "fk": string; }, options?: any) {
            return MessageApiFp.messagePrototypeUnlinkAccountEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for accessTokens.
         * @param id Message id
         * @param fk Foreign key for accessTokens
         * @param data 
         */
        messagePrototypeUpdateByIdAccountAccessTokens(params: {  "id": string; "fk": string; "data"?: AccessToken; }, options?: any) {
            return MessageApiFp.messagePrototypeUpdateByIdAccountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for effectScripts.
         * @param id Message id
         * @param fk Foreign key for effectScripts
         * @param data 
         */
        messagePrototypeUpdateByIdAccountEffectScripts(params: {  "id": string; "fk": string; "data"?: EffectScript; }, options?: any) {
            return MessageApiFp.messagePrototypeUpdateByIdAccountEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for histories.
         * @param id Message id
         * @param fk Foreign key for histories
         * @param data 
         */
        messagePrototypeUpdateByIdAccountHistories(params: {  "id": string; "fk": string; "data"?: History; }, options?: any) {
            return MessageApiFp.messagePrototypeUpdateByIdAccountHistories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for messages.
         * @param id Message id
         * @param fk Foreign key for messages
         * @param data 
         */
        messagePrototypeUpdateByIdAccountMessages(params: {  "id": string; "fk": string; "data"?: Message; }, options?: any) {
            return MessageApiFp.messagePrototypeUpdateByIdAccountMessages(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        messageReplaceByIdPostMessagesidReplace(params: {  "id": string; "data"?: Message; }, options?: any) {
            return MessageApiFp.messageReplaceByIdPostMessagesidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        messageReplaceByIdPutMessagesid(params: {  "id": string; "data"?: Message; }, options?: any) {
            return MessageApiFp.messageReplaceByIdPutMessagesid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        messageReplaceOrCreatePostMessagesReplaceOrCreate(params: {  "data"?: Message; }, options?: any) {
            return MessageApiFp.messageReplaceOrCreatePostMessagesReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        messageReplaceOrCreatePutMessages(params: {  "data"?: Message; }, options?: any) {
            return MessageApiFp.messageReplaceOrCreatePutMessages(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        messageUpdateAll(params: {  "where"?: string; "data"?: Message; }, options?: any) {
            return MessageApiFp.messageUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        messageUpsertWithWhere(params: {  "where"?: string; "data"?: Message; }, options?: any) {
            return MessageApiFp.messageUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * PayEffectScriptApi - fetch parameter creator
 */
export const PayEffectScriptApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    payEffectScriptCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/PayEffectScripts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    payEffectScriptCreate(params: {  "data"?: PayEffectScript; }, options?: any): FetchArgs {
        const baseUrl = `/PayEffectScripts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    payEffectScriptCreateChangeStreamGetPayEffectScriptsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/PayEffectScripts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    payEffectScriptCreateChangeStreamPostPayEffectScriptsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/PayEffectScripts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    payEffectScriptDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling payEffectScriptDeleteById");
        }
        const baseUrl = `/PayEffectScripts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    payEffectScriptExistsGetPayEffectScriptsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling payEffectScriptExistsGetPayEffectScriptsidExists");
        }
        const baseUrl = `/PayEffectScripts/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    payEffectScriptExistsHeadPayEffectScriptsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling payEffectScriptExistsHeadPayEffectScriptsid");
        }
        const baseUrl = `/PayEffectScripts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    payEffectScriptFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/PayEffectScripts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    payEffectScriptFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling payEffectScriptFindById");
        }
        const baseUrl = `/PayEffectScripts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    payEffectScriptFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/PayEffectScripts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    payEffectScriptPatchOrCreate(params: {  "data"?: PayEffectScript; }, options?: any): FetchArgs {
        const baseUrl = `/PayEffectScripts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id PayEffectScript id
     * @param refresh 
     */
    payEffectScriptPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling payEffectScriptPrototypeGetAccount");
        }
        const baseUrl = `/PayEffectScripts/{id}/account`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation effectScript.
     * @param id PayEffectScript id
     * @param refresh 
     */
    payEffectScriptPrototypeGetEffectScript(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling payEffectScriptPrototypeGetEffectScript");
        }
        const baseUrl = `/PayEffectScripts/{id}/effectScript`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id PayEffectScript id
     * @param data An object of model property name/value pairs
     */
    payEffectScriptPrototypePatchAttributes(params: {  "id": string; "data"?: PayEffectScript; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling payEffectScriptPrototypePatchAttributes");
        }
        const baseUrl = `/PayEffectScripts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    payEffectScriptReplaceByIdPostPayEffectScriptsidReplace(params: {  "id": string; "data"?: PayEffectScript; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling payEffectScriptReplaceByIdPostPayEffectScriptsidReplace");
        }
        const baseUrl = `/PayEffectScripts/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    payEffectScriptReplaceByIdPutPayEffectScriptsid(params: {  "id": string; "data"?: PayEffectScript; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling payEffectScriptReplaceByIdPutPayEffectScriptsid");
        }
        const baseUrl = `/PayEffectScripts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    payEffectScriptReplaceOrCreatePostPayEffectScriptsReplaceOrCreate(params: {  "data"?: PayEffectScript; }, options?: any): FetchArgs {
        const baseUrl = `/PayEffectScripts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    payEffectScriptReplaceOrCreatePutPayEffectScripts(params: {  "data"?: PayEffectScript; }, options?: any): FetchArgs {
        const baseUrl = `/PayEffectScripts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    payEffectScriptUpdateAll(params: {  "where"?: string; "data"?: PayEffectScript; }, options?: any): FetchArgs {
        const baseUrl = `/PayEffectScripts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    payEffectScriptUpsertWithWhere(params: {  "where"?: string; "data"?: PayEffectScript; }, options?: any): FetchArgs {
        const baseUrl = `/PayEffectScripts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PayEffectScriptApi - functional programming interface
 */
export const PayEffectScriptApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    payEffectScriptCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = PayEffectScriptApiFetchParamCreator.payEffectScriptCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    payEffectScriptCreate(params: { "data"?: PayEffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayEffectScript> {
        const fetchArgs = PayEffectScriptApiFetchParamCreator.payEffectScriptCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    payEffectScriptCreateChangeStreamGetPayEffectScriptsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PayEffectScriptApiFetchParamCreator.payEffectScriptCreateChangeStreamGetPayEffectScriptsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    payEffectScriptCreateChangeStreamPostPayEffectScriptsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PayEffectScriptApiFetchParamCreator.payEffectScriptCreateChangeStreamPostPayEffectScriptsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    payEffectScriptDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PayEffectScriptApiFetchParamCreator.payEffectScriptDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    payEffectScriptExistsGetPayEffectScriptsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = PayEffectScriptApiFetchParamCreator.payEffectScriptExistsGetPayEffectScriptsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    payEffectScriptExistsHeadPayEffectScriptsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = PayEffectScriptApiFetchParamCreator.payEffectScriptExistsHeadPayEffectScriptsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    payEffectScriptFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PayEffectScript>> {
        const fetchArgs = PayEffectScriptApiFetchParamCreator.payEffectScriptFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    payEffectScriptFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayEffectScript> {
        const fetchArgs = PayEffectScriptApiFetchParamCreator.payEffectScriptFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    payEffectScriptFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayEffectScript> {
        const fetchArgs = PayEffectScriptApiFetchParamCreator.payEffectScriptFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    payEffectScriptPatchOrCreate(params: { "data"?: PayEffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayEffectScript> {
        const fetchArgs = PayEffectScriptApiFetchParamCreator.payEffectScriptPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id PayEffectScript id
     * @param refresh 
     */
    payEffectScriptPrototypeGetAccount(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = PayEffectScriptApiFetchParamCreator.payEffectScriptPrototypeGetAccount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation effectScript.
     * @param id PayEffectScript id
     * @param refresh 
     */
    payEffectScriptPrototypeGetEffectScript(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EffectScript> {
        const fetchArgs = PayEffectScriptApiFetchParamCreator.payEffectScriptPrototypeGetEffectScript(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id PayEffectScript id
     * @param data An object of model property name/value pairs
     */
    payEffectScriptPrototypePatchAttributes(params: { "id": string; "data"?: PayEffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayEffectScript> {
        const fetchArgs = PayEffectScriptApiFetchParamCreator.payEffectScriptPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    payEffectScriptReplaceByIdPostPayEffectScriptsidReplace(params: { "id": string; "data"?: PayEffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayEffectScript> {
        const fetchArgs = PayEffectScriptApiFetchParamCreator.payEffectScriptReplaceByIdPostPayEffectScriptsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    payEffectScriptReplaceByIdPutPayEffectScriptsid(params: { "id": string; "data"?: PayEffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayEffectScript> {
        const fetchArgs = PayEffectScriptApiFetchParamCreator.payEffectScriptReplaceByIdPutPayEffectScriptsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    payEffectScriptReplaceOrCreatePostPayEffectScriptsReplaceOrCreate(params: { "data"?: PayEffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayEffectScript> {
        const fetchArgs = PayEffectScriptApiFetchParamCreator.payEffectScriptReplaceOrCreatePostPayEffectScriptsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    payEffectScriptReplaceOrCreatePutPayEffectScripts(params: { "data"?: PayEffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayEffectScript> {
        const fetchArgs = PayEffectScriptApiFetchParamCreator.payEffectScriptReplaceOrCreatePutPayEffectScripts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    payEffectScriptUpdateAll(params: { "where"?: string; "data"?: PayEffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = PayEffectScriptApiFetchParamCreator.payEffectScriptUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    payEffectScriptUpsertWithWhere(params: { "where"?: string; "data"?: PayEffectScript;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayEffectScript> {
        const fetchArgs = PayEffectScriptApiFetchParamCreator.payEffectScriptUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PayEffectScriptApi - object-oriented interface
 */
export class PayEffectScriptApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    payEffectScriptCount(params: {  "where"?: string; }, options?: any) {
        return PayEffectScriptApiFp.payEffectScriptCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    payEffectScriptCreate(params: {  "data"?: PayEffectScript; }, options?: any) {
        return PayEffectScriptApiFp.payEffectScriptCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    payEffectScriptCreateChangeStreamGetPayEffectScriptsChangeStream(params: {  "options"?: string; }, options?: any) {
        return PayEffectScriptApiFp.payEffectScriptCreateChangeStreamGetPayEffectScriptsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    payEffectScriptCreateChangeStreamPostPayEffectScriptsChangeStream(params: {  "options"?: string; }, options?: any) {
        return PayEffectScriptApiFp.payEffectScriptCreateChangeStreamPostPayEffectScriptsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    payEffectScriptDeleteById(params: {  "id": string; }, options?: any) {
        return PayEffectScriptApiFp.payEffectScriptDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    payEffectScriptExistsGetPayEffectScriptsidExists(params: {  "id": string; }, options?: any) {
        return PayEffectScriptApiFp.payEffectScriptExistsGetPayEffectScriptsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    payEffectScriptExistsHeadPayEffectScriptsid(params: {  "id": string; }, options?: any) {
        return PayEffectScriptApiFp.payEffectScriptExistsHeadPayEffectScriptsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    payEffectScriptFind(params: {  "filter"?: string; }, options?: any) {
        return PayEffectScriptApiFp.payEffectScriptFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    payEffectScriptFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return PayEffectScriptApiFp.payEffectScriptFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    payEffectScriptFindOne(params: {  "filter"?: string; }, options?: any) {
        return PayEffectScriptApiFp.payEffectScriptFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    payEffectScriptPatchOrCreate(params: {  "data"?: PayEffectScript; }, options?: any) {
        return PayEffectScriptApiFp.payEffectScriptPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id PayEffectScript id
     * @param refresh 
     */
    payEffectScriptPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return PayEffectScriptApiFp.payEffectScriptPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation effectScript.
     * @param id PayEffectScript id
     * @param refresh 
     */
    payEffectScriptPrototypeGetEffectScript(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return PayEffectScriptApiFp.payEffectScriptPrototypeGetEffectScript(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id PayEffectScript id
     * @param data An object of model property name/value pairs
     */
    payEffectScriptPrototypePatchAttributes(params: {  "id": string; "data"?: PayEffectScript; }, options?: any) {
        return PayEffectScriptApiFp.payEffectScriptPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    payEffectScriptReplaceByIdPostPayEffectScriptsidReplace(params: {  "id": string; "data"?: PayEffectScript; }, options?: any) {
        return PayEffectScriptApiFp.payEffectScriptReplaceByIdPostPayEffectScriptsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    payEffectScriptReplaceByIdPutPayEffectScriptsid(params: {  "id": string; "data"?: PayEffectScript; }, options?: any) {
        return PayEffectScriptApiFp.payEffectScriptReplaceByIdPutPayEffectScriptsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    payEffectScriptReplaceOrCreatePostPayEffectScriptsReplaceOrCreate(params: {  "data"?: PayEffectScript; }, options?: any) {
        return PayEffectScriptApiFp.payEffectScriptReplaceOrCreatePostPayEffectScriptsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    payEffectScriptReplaceOrCreatePutPayEffectScripts(params: {  "data"?: PayEffectScript; }, options?: any) {
        return PayEffectScriptApiFp.payEffectScriptReplaceOrCreatePutPayEffectScripts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    payEffectScriptUpdateAll(params: {  "where"?: string; "data"?: PayEffectScript; }, options?: any) {
        return PayEffectScriptApiFp.payEffectScriptUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    payEffectScriptUpsertWithWhere(params: {  "where"?: string; "data"?: PayEffectScript; }, options?: any) {
        return PayEffectScriptApiFp.payEffectScriptUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PayEffectScriptApi - factory interface
 */
export const PayEffectScriptApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        payEffectScriptCount(params: {  "where"?: string; }, options?: any) {
            return PayEffectScriptApiFp.payEffectScriptCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        payEffectScriptCreate(params: {  "data"?: PayEffectScript; }, options?: any) {
            return PayEffectScriptApiFp.payEffectScriptCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        payEffectScriptCreateChangeStreamGetPayEffectScriptsChangeStream(params: {  "options"?: string; }, options?: any) {
            return PayEffectScriptApiFp.payEffectScriptCreateChangeStreamGetPayEffectScriptsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        payEffectScriptCreateChangeStreamPostPayEffectScriptsChangeStream(params: {  "options"?: string; }, options?: any) {
            return PayEffectScriptApiFp.payEffectScriptCreateChangeStreamPostPayEffectScriptsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        payEffectScriptDeleteById(params: {  "id": string; }, options?: any) {
            return PayEffectScriptApiFp.payEffectScriptDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        payEffectScriptExistsGetPayEffectScriptsidExists(params: {  "id": string; }, options?: any) {
            return PayEffectScriptApiFp.payEffectScriptExistsGetPayEffectScriptsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        payEffectScriptExistsHeadPayEffectScriptsid(params: {  "id": string; }, options?: any) {
            return PayEffectScriptApiFp.payEffectScriptExistsHeadPayEffectScriptsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        payEffectScriptFind(params: {  "filter"?: string; }, options?: any) {
            return PayEffectScriptApiFp.payEffectScriptFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        payEffectScriptFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return PayEffectScriptApiFp.payEffectScriptFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        payEffectScriptFindOne(params: {  "filter"?: string; }, options?: any) {
            return PayEffectScriptApiFp.payEffectScriptFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        payEffectScriptPatchOrCreate(params: {  "data"?: PayEffectScript; }, options?: any) {
            return PayEffectScriptApiFp.payEffectScriptPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation account.
         * @param id PayEffectScript id
         * @param refresh 
         */
        payEffectScriptPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return PayEffectScriptApiFp.payEffectScriptPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation effectScript.
         * @param id PayEffectScript id
         * @param refresh 
         */
        payEffectScriptPrototypeGetEffectScript(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return PayEffectScriptApiFp.payEffectScriptPrototypeGetEffectScript(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id PayEffectScript id
         * @param data An object of model property name/value pairs
         */
        payEffectScriptPrototypePatchAttributes(params: {  "id": string; "data"?: PayEffectScript; }, options?: any) {
            return PayEffectScriptApiFp.payEffectScriptPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        payEffectScriptReplaceByIdPostPayEffectScriptsidReplace(params: {  "id": string; "data"?: PayEffectScript; }, options?: any) {
            return PayEffectScriptApiFp.payEffectScriptReplaceByIdPostPayEffectScriptsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        payEffectScriptReplaceByIdPutPayEffectScriptsid(params: {  "id": string; "data"?: PayEffectScript; }, options?: any) {
            return PayEffectScriptApiFp.payEffectScriptReplaceByIdPutPayEffectScriptsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        payEffectScriptReplaceOrCreatePostPayEffectScriptsReplaceOrCreate(params: {  "data"?: PayEffectScript; }, options?: any) {
            return PayEffectScriptApiFp.payEffectScriptReplaceOrCreatePostPayEffectScriptsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        payEffectScriptReplaceOrCreatePutPayEffectScripts(params: {  "data"?: PayEffectScript; }, options?: any) {
            return PayEffectScriptApiFp.payEffectScriptReplaceOrCreatePutPayEffectScripts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        payEffectScriptUpdateAll(params: {  "where"?: string; "data"?: PayEffectScript; }, options?: any) {
            return PayEffectScriptApiFp.payEffectScriptUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        payEffectScriptUpsertWithWhere(params: {  "where"?: string; "data"?: PayEffectScript; }, options?: any) {
            return PayEffectScriptApiFp.payEffectScriptUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * UserApi - fetch parameter creator
 */
export const UserApiFetchParamCreator = {
    /**
     * 
     * @summary Change a user's password.
     * @param oldPassword 
     * @param newPassword 
     */
    userChangePassword(params: {  "oldPassword": string; "newPassword": string; }, options?: any): FetchArgs {
        // verify required parameter "oldPassword" is set
        if (params["oldPassword"] == null) {
            throw new Error("Missing required parameter oldPassword when calling userChangePassword");
        }
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling userChangePassword");
        }
        const baseUrl = `/Users/change-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "oldPassword": params["oldPassword"],
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param uid 
     * @param token 
     * @param redirect 
     */
    userConfirm(params: {  "uid": string; "token": string; "redirect"?: string; }, options?: any): FetchArgs {
        // verify required parameter "uid" is set
        if (params["uid"] == null) {
            throw new Error("Missing required parameter uid when calling userConfirm");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            throw new Error("Missing required parameter token when calling userConfirm");
        }
        const baseUrl = `/Users/confirm`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "uid": params["uid"],
            "token": params["token"],
            "redirect": params["redirect"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    userCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Users/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    userCreate(params: {  "data"?: User; }, options?: any): FetchArgs {
        const baseUrl = `/Users`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    userCreateChangeStreamGetUsersChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Users/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    userCreateChangeStreamPostUsersChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Users/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    userDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userDeleteById");
        }
        const baseUrl = `/Users/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    userExistsGetUsersidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userExistsGetUsersidExists");
        }
        const baseUrl = `/Users/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    userExistsHeadUsersid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userExistsHeadUsersid");
        }
        const baseUrl = `/Users/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    userFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Users`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    userFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userFindById");
        }
        const baseUrl = `/Users/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    userFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Users/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Login a user with username/email and password.
     * @param credentials 
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    userLogin(params: {  "credentials": any; "include"?: string; }, options?: any): FetchArgs {
        // verify required parameter "credentials" is set
        if (params["credentials"] == null) {
            throw new Error("Missing required parameter credentials when calling userLogin");
        }
        const baseUrl = `/Users/login`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "include": params["include"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["credentials"]) {
            fetchOptions.body = JSON.stringify(params["credentials"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Logout a user with access token.
     */
    userLogout(options?: any): FetchArgs {
        const baseUrl = `/Users/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userPatchOrCreate(params: {  "data"?: User; }, options?: any): FetchArgs {
        const baseUrl = `/Users`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts accessTokens of User.
     * @param id User id
     * @param where Criteria to match model instances
     */
    userPrototypeCountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userPrototypeCountAccessTokens");
        }
        const baseUrl = `/Users/{id}/accessTokens/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id User id
     * @param data 
     */
    userPrototypeCreateAccessTokens(params: {  "id": string; "data"?: AccessToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userPrototypeCreateAccessTokens");
        }
        const baseUrl = `/Users/{id}/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id User id
     */
    userPrototypeDeleteAccessTokens(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userPrototypeDeleteAccessTokens");
        }
        const baseUrl = `/Users/{id}/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     */
    userPrototypeDestroyByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userPrototypeDestroyByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling userPrototypeDestroyByIdAccessTokens");
        }
        const baseUrl = `/Users/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     */
    userPrototypeFindByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userPrototypeFindByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling userPrototypeFindByIdAccessTokens");
        }
        const baseUrl = `/Users/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries accessTokens of User.
     * @param id User id
     * @param filter 
     */
    userPrototypeGetAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userPrototypeGetAccessTokens");
        }
        const baseUrl = `/Users/{id}/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id User id
     * @param data An object of model property name/value pairs
     */
    userPrototypePatchAttributes(params: {  "id": string; "data"?: User; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userPrototypePatchAttributes");
        }
        const baseUrl = `/Users/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    userPrototypeUpdateByIdAccessTokens(params: {  "id": string; "fk": string; "data"?: AccessToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userPrototypeUpdateByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling userPrototypeUpdateByIdAccessTokens");
        }
        const baseUrl = `/Users/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id User id
     */
    userPrototypeVerify(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userPrototypeVerify");
        }
        const baseUrl = `/Users/{id}/verify`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    userReplaceByIdPostUsersidReplace(params: {  "id": string; "data"?: User; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userReplaceByIdPostUsersidReplace");
        }
        const baseUrl = `/Users/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    userReplaceByIdPutUsersid(params: {  "id": string; "data"?: User; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userReplaceByIdPutUsersid");
        }
        const baseUrl = `/Users/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userReplaceOrCreatePostUsersReplaceOrCreate(params: {  "data"?: User; }, options?: any): FetchArgs {
        const baseUrl = `/Users/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userReplaceOrCreatePutUsers(params: {  "data"?: User; }, options?: any): FetchArgs {
        const baseUrl = `/Users`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Reset password for a user with email.
     * @param options 
     */
    userResetPassword(params: {  "options": any; }, options?: any): FetchArgs {
        // verify required parameter "options" is set
        if (params["options"] == null) {
            throw new Error("Missing required parameter options when calling userResetPassword");
        }
        const baseUrl = `/Users/reset`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["options"]) {
            fetchOptions.body = JSON.stringify(params["options"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param newPassword 
     */
    userSetPassword(params: {  "newPassword": string; }, options?: any): FetchArgs {
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling userSetPassword");
        }
        const baseUrl = `/Users/reset-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    userUpdateAll(params: {  "where"?: string; "data"?: User; }, options?: any): FetchArgs {
        const baseUrl = `/Users/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    userUpsertWithWhere(params: {  "where"?: string; "data"?: User; }, options?: any): FetchArgs {
        const baseUrl = `/Users/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = {
    /**
     * 
     * @summary Change a user's password.
     * @param oldPassword 
     * @param newPassword 
     */
    userChangePassword(params: { "oldPassword": string; "newPassword": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userChangePassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param uid 
     * @param token 
     * @param redirect 
     */
    userConfirm(params: { "uid": string; "token": string; "redirect"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userConfirm(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    userCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = UserApiFetchParamCreator.userCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    userCreate(params: { "data"?: User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.userCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    userCreateChangeStreamGetUsersChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userCreateChangeStreamGetUsersChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    userCreateChangeStreamPostUsersChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userCreateChangeStreamPostUsersChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    userDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    userExistsGetUsersidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = UserApiFetchParamCreator.userExistsGetUsersidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    userExistsHeadUsersid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = UserApiFetchParamCreator.userExistsHeadUsersid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    userFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<User>> {
        const fetchArgs = UserApiFetchParamCreator.userFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    userFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.userFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    userFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.userFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Login a user with username/email and password.
     * @param credentials 
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    userLogin(params: { "credentials": any; "include"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userLogin(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Logout a user with access token.
     */
    userLogout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userLogout(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userPatchOrCreate(params: { "data"?: User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.userPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts accessTokens of User.
     * @param id User id
     * @param where Criteria to match model instances
     */
    userPrototypeCountAccessTokens(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = UserApiFetchParamCreator.userPrototypeCountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id User id
     * @param data 
     */
    userPrototypeCreateAccessTokens(params: { "id": string; "data"?: AccessToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
        const fetchArgs = UserApiFetchParamCreator.userPrototypeCreateAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id User id
     */
    userPrototypeDeleteAccessTokens(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userPrototypeDeleteAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     */
    userPrototypeDestroyByIdAccessTokens(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userPrototypeDestroyByIdAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     */
    userPrototypeFindByIdAccessTokens(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
        const fetchArgs = UserApiFetchParamCreator.userPrototypeFindByIdAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries accessTokens of User.
     * @param id User id
     * @param filter 
     */
    userPrototypeGetAccessTokens(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccessToken>> {
        const fetchArgs = UserApiFetchParamCreator.userPrototypeGetAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id User id
     * @param data An object of model property name/value pairs
     */
    userPrototypePatchAttributes(params: { "id": string; "data"?: User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.userPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    userPrototypeUpdateByIdAccessTokens(params: { "id": string; "fk": string; "data"?: AccessToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
        const fetchArgs = UserApiFetchParamCreator.userPrototypeUpdateByIdAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id User id
     */
    userPrototypeVerify(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userPrototypeVerify(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    userReplaceByIdPostUsersidReplace(params: { "id": string; "data"?: User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.userReplaceByIdPostUsersidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    userReplaceByIdPutUsersid(params: { "id": string; "data"?: User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.userReplaceByIdPutUsersid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userReplaceOrCreatePostUsersReplaceOrCreate(params: { "data"?: User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.userReplaceOrCreatePostUsersReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userReplaceOrCreatePutUsers(params: { "data"?: User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.userReplaceOrCreatePutUsers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Reset password for a user with email.
     * @param options 
     */
    userResetPassword(params: { "options": any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userResetPassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param newPassword 
     */
    userSetPassword(params: { "newPassword": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userSetPassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    userUpdateAll(params: { "where"?: string; "data"?: User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = UserApiFetchParamCreator.userUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    userUpsertWithWhere(params: { "where"?: string; "data"?: User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.userUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Change a user's password.
     * @param oldPassword 
     * @param newPassword 
     */
    userChangePassword(params: {  "oldPassword": string; "newPassword": string; }, options?: any) {
        return UserApiFp.userChangePassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param uid 
     * @param token 
     * @param redirect 
     */
    userConfirm(params: {  "uid": string; "token": string; "redirect"?: string; }, options?: any) {
        return UserApiFp.userConfirm(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    userCount(params: {  "where"?: string; }, options?: any) {
        return UserApiFp.userCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    userCreate(params: {  "data"?: User; }, options?: any) {
        return UserApiFp.userCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    userCreateChangeStreamGetUsersChangeStream(params: {  "options"?: string; }, options?: any) {
        return UserApiFp.userCreateChangeStreamGetUsersChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    userCreateChangeStreamPostUsersChangeStream(params: {  "options"?: string; }, options?: any) {
        return UserApiFp.userCreateChangeStreamPostUsersChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    userDeleteById(params: {  "id": string; }, options?: any) {
        return UserApiFp.userDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    userExistsGetUsersidExists(params: {  "id": string; }, options?: any) {
        return UserApiFp.userExistsGetUsersidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    userExistsHeadUsersid(params: {  "id": string; }, options?: any) {
        return UserApiFp.userExistsHeadUsersid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    userFind(params: {  "filter"?: string; }, options?: any) {
        return UserApiFp.userFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    userFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return UserApiFp.userFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    userFindOne(params: {  "filter"?: string; }, options?: any) {
        return UserApiFp.userFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Login a user with username/email and password.
     * @param credentials 
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    userLogin(params: {  "credentials": any; "include"?: string; }, options?: any) {
        return UserApiFp.userLogin(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Logout a user with access token.
     */
    userLogout(options?: any) {
        return UserApiFp.userLogout(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userPatchOrCreate(params: {  "data"?: User; }, options?: any) {
        return UserApiFp.userPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts accessTokens of User.
     * @param id User id
     * @param where Criteria to match model instances
     */
    userPrototypeCountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any) {
        return UserApiFp.userPrototypeCountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id User id
     * @param data 
     */
    userPrototypeCreateAccessTokens(params: {  "id": string; "data"?: AccessToken; }, options?: any) {
        return UserApiFp.userPrototypeCreateAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id User id
     */
    userPrototypeDeleteAccessTokens(params: {  "id": string; }, options?: any) {
        return UserApiFp.userPrototypeDeleteAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     */
    userPrototypeDestroyByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
        return UserApiFp.userPrototypeDestroyByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     */
    userPrototypeFindByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
        return UserApiFp.userPrototypeFindByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries accessTokens of User.
     * @param id User id
     * @param filter 
     */
    userPrototypeGetAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any) {
        return UserApiFp.userPrototypeGetAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id User id
     * @param data An object of model property name/value pairs
     */
    userPrototypePatchAttributes(params: {  "id": string; "data"?: User; }, options?: any) {
        return UserApiFp.userPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    userPrototypeUpdateByIdAccessTokens(params: {  "id": string; "fk": string; "data"?: AccessToken; }, options?: any) {
        return UserApiFp.userPrototypeUpdateByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id User id
     */
    userPrototypeVerify(params: {  "id": string; }, options?: any) {
        return UserApiFp.userPrototypeVerify(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    userReplaceByIdPostUsersidReplace(params: {  "id": string; "data"?: User; }, options?: any) {
        return UserApiFp.userReplaceByIdPostUsersidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    userReplaceByIdPutUsersid(params: {  "id": string; "data"?: User; }, options?: any) {
        return UserApiFp.userReplaceByIdPutUsersid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userReplaceOrCreatePostUsersReplaceOrCreate(params: {  "data"?: User; }, options?: any) {
        return UserApiFp.userReplaceOrCreatePostUsersReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userReplaceOrCreatePutUsers(params: {  "data"?: User; }, options?: any) {
        return UserApiFp.userReplaceOrCreatePutUsers(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Reset password for a user with email.
     * @param options 
     */
    userResetPassword(params: {  "options": any; }, options?: any) {
        return UserApiFp.userResetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param newPassword 
     */
    userSetPassword(params: {  "newPassword": string; }, options?: any) {
        return UserApiFp.userSetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    userUpdateAll(params: {  "where"?: string; "data"?: User; }, options?: any) {
        return UserApiFp.userUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    userUpsertWithWhere(params: {  "where"?: string; "data"?: User; }, options?: any) {
        return UserApiFp.userUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Change a user's password.
         * @param oldPassword 
         * @param newPassword 
         */
        userChangePassword(params: {  "oldPassword": string; "newPassword": string; }, options?: any) {
            return UserApiFp.userChangePassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Confirm a user registration with identity verification token.
         * @param uid 
         * @param token 
         * @param redirect 
         */
        userConfirm(params: {  "uid": string; "token": string; "redirect"?: string; }, options?: any) {
            return UserApiFp.userConfirm(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        userCount(params: {  "where"?: string; }, options?: any) {
            return UserApiFp.userCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        userCreate(params: {  "data"?: User; }, options?: any) {
            return UserApiFp.userCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        userCreateChangeStreamGetUsersChangeStream(params: {  "options"?: string; }, options?: any) {
            return UserApiFp.userCreateChangeStreamGetUsersChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        userCreateChangeStreamPostUsersChangeStream(params: {  "options"?: string; }, options?: any) {
            return UserApiFp.userCreateChangeStreamPostUsersChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        userDeleteById(params: {  "id": string; }, options?: any) {
            return UserApiFp.userDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        userExistsGetUsersidExists(params: {  "id": string; }, options?: any) {
            return UserApiFp.userExistsGetUsersidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        userExistsHeadUsersid(params: {  "id": string; }, options?: any) {
            return UserApiFp.userExistsHeadUsersid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        userFind(params: {  "filter"?: string; }, options?: any) {
            return UserApiFp.userFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        userFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return UserApiFp.userFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        userFindOne(params: {  "filter"?: string; }, options?: any) {
            return UserApiFp.userFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Login a user with username/email and password.
         * @param credentials 
         * @param include Related objects to include in the response. See the description of return value for more details.
         */
        userLogin(params: {  "credentials": any; "include"?: string; }, options?: any) {
            return UserApiFp.userLogin(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Logout a user with access token.
         */
        userLogout(options?: any) {
            return UserApiFp.userLogout(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        userPatchOrCreate(params: {  "data"?: User; }, options?: any) {
            return UserApiFp.userPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts accessTokens of User.
         * @param id User id
         * @param where Criteria to match model instances
         */
        userPrototypeCountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any) {
            return UserApiFp.userPrototypeCountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in accessTokens of this model.
         * @param id User id
         * @param data 
         */
        userPrototypeCreateAccessTokens(params: {  "id": string; "data"?: AccessToken; }, options?: any) {
            return UserApiFp.userPrototypeCreateAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all accessTokens of this model.
         * @param id User id
         */
        userPrototypeDeleteAccessTokens(params: {  "id": string; }, options?: any) {
            return UserApiFp.userPrototypeDeleteAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for accessTokens.
         * @param id User id
         * @param fk Foreign key for accessTokens
         */
        userPrototypeDestroyByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
            return UserApiFp.userPrototypeDestroyByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for accessTokens.
         * @param id User id
         * @param fk Foreign key for accessTokens
         */
        userPrototypeFindByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
            return UserApiFp.userPrototypeFindByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries accessTokens of User.
         * @param id User id
         * @param filter 
         */
        userPrototypeGetAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any) {
            return UserApiFp.userPrototypeGetAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id User id
         * @param data An object of model property name/value pairs
         */
        userPrototypePatchAttributes(params: {  "id": string; "data"?: User; }, options?: any) {
            return UserApiFp.userPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for accessTokens.
         * @param id User id
         * @param fk Foreign key for accessTokens
         * @param data 
         */
        userPrototypeUpdateByIdAccessTokens(params: {  "id": string; "fk": string; "data"?: AccessToken; }, options?: any) {
            return UserApiFp.userPrototypeUpdateByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Trigger user's identity verification with configured verifyOptions
         * @param id User id
         */
        userPrototypeVerify(params: {  "id": string; }, options?: any) {
            return UserApiFp.userPrototypeVerify(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        userReplaceByIdPostUsersidReplace(params: {  "id": string; "data"?: User; }, options?: any) {
            return UserApiFp.userReplaceByIdPostUsersidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        userReplaceByIdPutUsersid(params: {  "id": string; "data"?: User; }, options?: any) {
            return UserApiFp.userReplaceByIdPutUsersid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        userReplaceOrCreatePostUsersReplaceOrCreate(params: {  "data"?: User; }, options?: any) {
            return UserApiFp.userReplaceOrCreatePostUsersReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        userReplaceOrCreatePutUsers(params: {  "data"?: User; }, options?: any) {
            return UserApiFp.userReplaceOrCreatePutUsers(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reset password for a user with email.
         * @param options 
         */
        userResetPassword(params: {  "options": any; }, options?: any) {
            return UserApiFp.userResetPassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reset user's password via a password-reset token.
         * @param newPassword 
         */
        userSetPassword(params: {  "newPassword": string; }, options?: any) {
            return UserApiFp.userSetPassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        userUpdateAll(params: {  "where"?: string; "data"?: User; }, options?: any) {
            return UserApiFp.userUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        userUpsertWithWhere(params: {  "where"?: string; "data"?: User; }, options?: any) {
            return UserApiFp.userUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};

